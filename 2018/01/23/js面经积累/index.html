<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="js," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="一些判断 typeof操作符可以判断number,boolean,string,function,undefined; 判断array需要用array.isArray(arr); 判断null需要用myVar === null; 判断某个全局变量是否存在使用typeof window.myVar === &amp;#39;undefined&amp;#39;; 函数内部判断某个变量是否存在用typeof myVa">
<meta name="keywords" content="js">
<meta property="og:type" content="article">
<meta property="og:title" content="js面经积累">
<meta property="og:url" content="http://yoursite.com/2018/01/23/js面经积累/index.html">
<meta property="og:site_name" content="叶珵珵">
<meta property="og:description" content="一些判断 typeof操作符可以判断number,boolean,string,function,undefined; 判断array需要用array.isArray(arr); 判断null需要用myVar === null; 判断某个全局变量是否存在使用typeof window.myVar === &amp;#39;undefined&amp;#39;; 函数内部判断某个变量是否存在用typeof myVa">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://oy3ncu01s.bkt.clouddn.com/18-2-4/9211762.jpg">
<meta property="og:image" content="http://oy3ncu01s.bkt.clouddn.com/18-2-5/74495064.jpg">
<meta property="og:image" content="http://oy3ncu01s.bkt.clouddn.com/18-2-4/46881170.jpg">
<meta property="og:image" content="http://oy3ncu01s.bkt.clouddn.com/18-2-5/20522604.jpg">
<meta property="og:image" content="http://oy3ncu01s.bkt.clouddn.com/18-2-7/17444265.jpg">
<meta property="og:image" content="http://oy3ncu01s.bkt.clouddn.com/18-2-7/78699006.jpg">
<meta property="og:image" content="http://oy3ncu01s.bkt.clouddn.com/18-2-7/36694851.jpg">
<meta property="og:image" content="http://oy3ncu01s.bkt.clouddn.com/18-2-7/15467394.jpg">
<meta property="og:image" content="http://oy3ncu01s.bkt.clouddn.com/18-2-7/27858714.jpg">
<meta property="og:image" content="http://oy3ncu01s.bkt.clouddn.com/18-2-7/49380815.jpg">
<meta property="og:image" content="http://oy3ncu01s.bkt.clouddn.com/18-2-7/74930949.jpg">
<meta property="og:updated_time" content="2018-02-07T11:10:06.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="js面经积累">
<meta name="twitter:description" content="一些判断 typeof操作符可以判断number,boolean,string,function,undefined; 判断array需要用array.isArray(arr); 判断null需要用myVar === null; 判断某个全局变量是否存在使用typeof window.myVar === &amp;#39;undefined&amp;#39;; 函数内部判断某个变量是否存在用typeof myVa">
<meta name="twitter:image" content="http://oy3ncu01s.bkt.clouddn.com/18-2-4/9211762.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/01/23/js面经积累/"/>





  <title>js面经积累 | 叶珵珵</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">叶珵珵</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Personal Notebook</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-search">
          <a href="/搜索" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            搜索
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/23/js面经积累/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ycccheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="叶珵珵">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">js面经积累</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-23T15:59:15+08:00">
                2018-01-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="一些判断"><a href="#一些判断" class="headerlink" title="一些判断"></a>一些判断</h4><ul>
<li><code>typeof</code>操作符可以判断<code>number</code>,<code>boolean</code>,<code>string</code>,<code>function</code>,<code>undefined</code>;</li>
<li>判断<code>array</code>需要用<code>array.isArray(arr)</code>;</li>
<li>判断<code>null</code>需要用<code>myVar === null</code>;</li>
<li>判断某个全局变量是否存在使用<code>typeof window.myVar === &#39;undefined&#39;</code>;</li>
<li>函数内部判断某个变量是否存在用<code>typeof myVar === &#39;undefined&#39;</code> </li>
</ul>
<a id="more"></a>
<h4 id="for…in-和-for…of-的区别"><a href="#for…in-和-for…of-的区别" class="headerlink" title="for…in 和 for…of 的区别"></a>for…in 和 for…of 的区别</h4><p><code>for...in</code>由于历史遗留问题，它的遍历实际上是对象属性的遍历，一个array数组实际上也是一个对象，对象属性即是数据的索引</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">in</span> arr)&#123;</div><div class="line">    <span class="built_in">console</span>.log(x); <span class="comment">//0,1,2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>for...of</code>循环则完全修复了这些问题，它只循环集合本身的元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">a.name = <span class="string">'Hello'</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123;</div><div class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 'A', 'B', 'C'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a><code>rest</code>参数</h4><p>es6引入<code>rest</code>参数，为了获得额外的参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'a = '</span> + a);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'b = '</span> + b);</div><div class="line">    <span class="built_in">console</span>.log(rest);</div><div class="line">&#125;</div><div class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</div><div class="line"><span class="comment">// a = 1   b = 2   Array [ 3, 4, 5 ]</span></div><div class="line"></div><div class="line">foo(<span class="number">1</span>);</div><div class="line"><span class="comment">//a = 1   b = undefined    Array []</span></div></pre></td></tr></table></figure>
<hr>
<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>函数定义有个特点，他会先扫描整个函数体的语句，把所有声明的变量提升到函数顶部</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="string">'Hello, '</span> + y;</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">    <span class="keyword">var</span> y = <span class="string">'Bob'</span>;</div><div class="line">&#125;</div><div class="line">foo(); <span class="comment">//hello,unddefined</span></div></pre></td></tr></table></figure>
<p>上函数体内的第一句并不会报错，因为y变量在后面已经声明了，但函数尚未运行到该句，所以y此时是<code>undefined</code></p>
<p>由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量</p>
<h4 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h4><p>全局变量会绑定到<code>window</code>上，不同的js文件如果使用了相同的全局变量，或者定义了相同的顶层函数，都会造成命名冲突。减少这种冲突的方法就是把自己的所有变量和函数全部绑定到一个全局变量中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 唯一的全局变量MYAPP:</span></div><div class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 其他变量:</span></div><div class="line">MYAPP.name = <span class="string">'myapp'</span>;</div><div class="line">MYAPP.version = <span class="number">1.0</span>;</div><div class="line"></div><div class="line"><span class="comment">// 其他函数:</span></div><div class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="let-const"><a href="#let-const" class="headerlink" title="let const"></a><code>let</code> <code>const</code></h4><p><code>let</code>用来声明变量，与<code>var</code>类似。但let声明的变量只在所在的代码块中有效。</p>
<p>为了纠正<code>var</code>变量提升的现象，<code>let</code>声明的变量不存在变量提升，所有的变量必须在声明后使用。如果在变量声明之前调用，则会报错，语法上称<br>为‘暂时性死区’。</p>
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。并且只在块级作用域中有效。也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>从数组和对象中提取值，对变量进行赋值，这被称为解构,属于模式匹配。并允许指定默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</div><div class="line">foo <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></div></pre></td></tr></table></figure>
<p><strong>对象</strong>的解构赋值与数组不同，对象的解构必须属性名一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">foo <span class="comment">// "aaa"</span></div><div class="line">bar <span class="comment">// "bbb"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">baz <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">baz <span class="comment">// "aaa"</span></div><div class="line">foo <span class="comment">// error: foo is not defined</span></div></pre></td></tr></table></figure>
<p><strong>字符串</strong>的解构赋值是把字符串转化成了类似于数组的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [a,b,c,d,e] = <span class="string">'hello'</span>;</div><div class="line">a; <span class="comment">//'h'</span></div></pre></td></tr></table></figure>
<p><strong>数值</strong>和<strong>布尔值</strong>的解构赋值是先将数值和布尔值转化成对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</div><div class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</div><div class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h4 id="apply和call"><a href="#apply和call" class="headerlink" title="apply和call"></a><code>apply</code>和<code>call</code></h4><p>两者都是用来引入另一个对象的方法，或是用另一个对象替换当前的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">B.apply(A,[argument1, argument2]);<span class="comment">//A对象调用B对象的方法，this指向A</span></div><div class="line">B.apply(A,argument1, argument2);<span class="comment">//A对象调用B对象的方法，this指向A</span></div></pre></td></tr></table></figure>
<p>唯一区别：传入参数的表示形式不同</p>
<ol>
<li><p><code>apply()</code>把参数打包成Array再传入；</p>
</li>
<li><p><code>call()</code>把参数按顺序传入。 </p>
</li>
</ol>
<h4 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h4><p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数内部的<code>this</code>是词法作用域，由上下文确定。比较下面两个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    birth: <span class="number">1990</span>,</div><div class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></div><div class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; </div><div class="line">        <span class="comment">// this指向window或undefined,通过var that = this来修正this的指向。</span></div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">return</span> fn();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>箭头函数修复了<code>this</code>的指向问题，指向词法作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    birth: <span class="number">1990</span>,</div><div class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></div><div class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向obj对象</span></div><div class="line">        <span class="keyword">return</span> fn();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">obj.getAge(); <span class="comment">// 25</span></div></pre></td></tr></table></figure>
<h4 id="事件代理-委托"><a href="#事件代理-委托" class="headerlink" title="事件代理/委托"></a>事件代理/委托</h4><p><a href="https://zhuanlan.zhihu.com/p/26536815" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/26536815</a></p>
<p>通俗的讲，就是把一个元素的响应事件委托给另外一个元素，通过目标元的判断来确定事件函数的触发。</p>
<p>事件模型分为三个阶段：</p>
<ul>
<li>事件捕获：事件从文档根节点触发，根据DOM树结构依次向目标节点流去，途中经过各个层次的节点，并在节点上触发捕获事件，直到到达目标节点（在事件魔炮的模型中，捕获阶段不会响应任何事件）</li>
<li>目标阶段：事件响应到触发事件的最底层元素上；</li>
<li>冒泡阶段：事件依次由最底层的目标节点向父元素冒泡，直到根节点。（<strong>事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层</strong>）</li>
</ul>
<p><img src="http://oy3ncu01s.bkt.clouddn.com/18-2-4/9211762.jpg" alt=""></p>
<p>优点：</p>
<ul>
<li>减少内存消耗</li>
<li>动态绑定事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 给父层元素绑定事件</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'list'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="comment">// 兼容性处理</span></div><div class="line">  <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event;</div><div class="line">  <span class="keyword">var</span> target = event.target || event.srcElement;</div><div class="line">  <span class="comment">// 判断是否匹配目标元素</span></div><div class="line">  <span class="keyword">if</span> (target.nodeName.toLocaleLowerCase === <span class="string">'li'</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'the content is: '</span>, target.innerHTML);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<hr>
<h4 id="请解释-JavaScript-中-this-是如何工作的"><a href="#请解释-JavaScript-中-this-是如何工作的" class="headerlink" title="请解释 JavaScript 中 this 是如何工作的"></a>请解释 JavaScript 中 <code>this</code> 是如何工作的</h4><p><a href="http://snailsky.me/2014/08/31/javascript-%E4%B8%AD-this-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/" target="_blank" rel="external">http://snailsky.me/2014/08/31/javascript-%E4%B8%AD-this-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/</a></p>
<p><code>this</code>就是指当前函数的运行环境。由于js支持运行环境的动态切换，所以this指向也是动态的；this指函数运行时所在的那个对象。</p>
<ul>
<li>全局环境 this指向顶层对象window</li>
<li>构造函数 this指向实例对象</li>
<li><p>方法调用</p>
<p>  当A对象的方法赋给了B对象，改方法就变成了普通函数，其this指向就从A对象变成了B对象，这就是this取决于运行时所在的对象的含义。付过将某个对象的方法赋给另外一个对象，会改变this指向</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">o1.m = <span class="number">1</span>;</div><div class="line">o1.f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.m);&#125;;</div><div class="line">o1.f() <span class="comment">// 1</span></div><div class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">o2.m = <span class="number">2</span>;</div><div class="line">o2.f = o1.f</div><div class="line">o2.f() <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<hr>
<h4 id="bind方法"><a href="#bind方法" class="headerlink" title="bind方法"></a><code>bind</code>方法</h4><p><a href="http://blog.jobbole.com/58032/" target="_blank" rel="external">http://blog.jobbole.com/58032/</a></p>
<p>地将函数体内的this绑定到某个对象，然后返回一个新函数（返回由指定的this值和初始化参数改造的原函数拷贝）。它的使用格式如下。</p>
<p><code>B.bind(A,arg1,arg2)</code> //this指向A;如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">o1.p = <span class="number">123</span>;</div><div class="line">o1.m = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.p);</div><div class="line">&#125;;</div><div class="line">o1.m() <span class="comment">// 123</span></div><div class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">o2.p = <span class="number">456</span>;</div><div class="line">o2.m = o1.m;</div><div class="line">o2.m() <span class="comment">// 456</span></div><div class="line">o2.m = o1.m.bind(o1);</div><div class="line">o2.m() <span class="comment">// 123</span></div></pre></td></tr></table></figure>
<hr>
<h4 id="你怎么看-AMD-vs-CommonJS"><a href="#你怎么看-AMD-vs-CommonJS" class="headerlink" title="你怎么看 AMD vs. CommonJS"></a>你怎么看 AMD vs. CommonJS</h4><p>commmenJS主要运用于服务器模块，node使用的就是commonJS规范，用于服务器端环境。commonJS规范属于<strong>同步加载模</strong>块，对于服务器端这并不是一个问题，因为所有的模块都存放在本地磁盘，所以加载时间并不是问题；而到了浏览器端，可能会造成较长的等待时间，造成页面‘假死’。</p>
<p>因此浏览器端的模块不能采用‘同步加载’，所以就有了AMD规范。</p>
<p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<p><code>require([module],callback)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'msth'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">math</span>)</span>&#123;</div><div class="line">	math.add(<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。<br><a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html</a></p>
<hr>
<h4 id="IIFE立即执行函数表达式"><a href="#IIFE立即执行函数表达式" class="headerlink" title="IIFE立即执行函数表达式"></a>IIFE立即执行函数表达式</h4><p><a href="https://segmentfault.com/a/1190000003902899" target="_blank" rel="external">https://segmentfault.com/a/1190000003902899</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span></span>&#123;...&#125;;	<span class="comment">//立即执行函数表达式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;...&#125;();	<span class="comment">//报错</span></div></pre></td></tr></table></figure>
<p>上面第二个例子会报错，是因为<code>function</code>关键字既可以当做语句，也可以当做表达式，当<code>function</code>出现在行头时，一律解释为语句和一般的函数定义。所以下面的是正确的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;...&#125;());	<span class="comment">//推荐使用这个</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;...&#125;)();	<span class="comment">//也可以使用这个</span></div><div class="line"></div><div class="line"><span class="comment">// 由于括弧()和JS的&amp;&amp;，异或，逗号等操作符是在函数表达式和函数声明上消除歧义的</span></div><div class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125; ();</div><div class="line"><span class="literal">true</span> &amp;&amp; <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ();</div><div class="line"><span class="number">0</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ();</div><div class="line"></div><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</div></pre></td></tr></table></figure>
<p>只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</p>
<hr>
<h4 id="null，undefined-或-undeclaredd的区别"><a href="#null，undefined-或-undeclaredd的区别" class="headerlink" title="null，undefined 或 undeclaredd的区别"></a>null，undefined 或 undeclaredd的区别</h4><p><code>null</code>是原始类型之一，表示对象值为空；使用<code>typeof</code>类型判断为<code>object</code>;与””,’’不等价。</p>
<p><code>undefind</code>只定义未赋值</p>
<p><code>undeclared</code>未定义变量就使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val === <span class="string">'object'</span> &amp;&amp; <span class="literal">null</span>;		<span class="comment">//判断null</span></div><div class="line"><span class="keyword">typeof</span>(val) === <span class="string">'undefined'</span>		<span class="comment">//判断undefined</span></div></pre></td></tr></table></figure>
<hr>
<h4 id="你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？"><a href="#你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？" class="headerlink" title="你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？"></a>你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？</h4><hr>
<h4 id="JavaScript-宿主对象-host-objects-和原生对象-native-objects-、内置对象-？"><a href="#JavaScript-宿主对象-host-objects-和原生对象-native-objects-、内置对象-？" class="headerlink" title="JavaScript 宿主对象 (host objects) 和原生对象 (native objects)、内置对象 ？"></a>JavaScript 宿主对象 (host objects) 和原生对象 (native objects)、内置对象 ？</h4><p><img src="http://oy3ncu01s.bkt.clouddn.com/18-2-5/74495064.jpg" alt=""></p>
<p>宿主对象：“宿主”当然就是我们网页的运行环境，即“操作系统”和“浏览器”。所有非原生对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。包括BOM（浏览器对象），DOM对象。</p>
<p><img src="http://oy3ncu01s.bkt.clouddn.com/18-2-4/46881170.jpg" alt=""></p>
<p>原生对象：“独立于宿主环境的 ECMAScript 实现提供的对象”。即ECMA定义的类（引用类型）</p>
<p>Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError、ActiveXObject(服务器方面)、Enumerator(集合遍历类)、RegExp（正则表达式）</p>
<p>内置对象：定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了。即 Global 和 Math</p>
<hr>
<h4 id="函数表达式与函数声明"><a href="#函数表达式与函数声明" class="headerlink" title="函数表达式与函数声明"></a>函数表达式与函数声明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;; 	<span class="comment">//函数声明 存在变量提升</span></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;	;	</div><div class="line"><span class="comment">//函数表达式 也会提升 但会先将变量赋值给undefined，定义本身不会提升</span></div></pre></td></tr></table></figure>
<p><a href="http://web.jobbole.com/87534/" target="_blank" rel="external">http://web.jobbole.com/87534/</a></p>
<hr>
<h4 id="在什么时候你会使用-document-write-？"><a href="#在什么时候你会使用-document-write-？" class="headerlink" title="在什么时候你会使用 document.write()？"></a>在什么时候你会使用 document.write()？</h4><p><a href="http://www.cnblogs.com/zichi/p/5303541.html" target="_blank" rel="external">http://www.cnblogs.com/zichi/p/5303541.html</a></p>
<p>document.write() 接收一个字符串作为参数，将该字符串写入文档流中。</p>
<p>在浏览器通过网络下载一个HTML文件时，需要做2个基本的事情：解析HTML流、构建DOM树解析HTML流即将HTML字符流变为一个语法可识别的token集合，说白了就是语法解析，随后基于解析后的token再形成我们熟知的DOM树如果使用document.write写入一个元素（无论是否是script），会造成HTML流被修改，此时浏览器需要额外做解析的工作，才可以继续DOM树的构建</p>
<p>而如果使用创建元素并append的方式，则只有DOM树发生变动，不需要额外的解析工作</p>
<p>除此之外，document.write出来的脚本会立即下载即行（同步阻塞），这会阻塞后续DOM的构建，如果这个脚本因网络等原因下载比较慢，页面就会处于半但是如果在后面有其它脚本依赖于你写入的script，那么使用document.write是一个比较好的选择，直接创建元素会导致异步让后续有依赖的脚本执行出错再者，</p>
<p>当页面已经完成加载（DOMContentLoaded事件触发）时，HTML流会被关闭，此时无法使用document.write，如果强制使用会使得原来的页面消失，这个大部分人都明白最后，</p>
<p>低版本的IE浏览器（如IE6）下，document.write写入的脚本执行时机是错误的，其时机控制非常复杂，如果你对脚本的执行顺序有要求的话，这一兼容性问题会让你头疼，这里摘录我以前做出的总结</p>
<hr>
<h4 id="请指出浏览器特性检测，特性推断和浏览器-UA-字符串嗅探的区别"><a href="#请指出浏览器特性检测，特性推断和浏览器-UA-字符串嗅探的区别" class="headerlink" title="请指出浏览器特性检测，特性推断和浏览器 UA 字符串嗅探的区别"></a>请指出浏览器特性检测，特性推断和浏览器 UA 字符串嗅探的区别</h4><p><a href="http://blog.720ui.com/2015/js_practice_03_useragent/" target="_blank" rel="external">http://blog.720ui.com/2015/js_practice_03_useragent/</a></p>
<p><strong>特性检测</strong></p>
<p>并非所有的浏览器都支持相同的特性，这里的特性是指对于JavaScript开发人员而言可以在代码中访问和使用的特性。特性检测是指检测浏览器是否支持某个给定特性的过程，该方法是浏览器检测的首选方法。使用该方法时，需要做少许的维护工作，所有实现（或不实现）特定特性的浏览器都使用这种方法来检测代码的执行。</p>
<p>特性检测的模式很简单：首先检查特性是否存在，如果存在，就使用该特性。因此，使用一个if语句即可实现，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(navigate.geolocation)&#123;</div><div class="line">	<span class="comment">//user geolocation</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>UA（user Agent用户代理）检测</strong></p>
<p>浏览器的嗅探主要基于Window对象的Navigator属性对浏览器的类型、名称、厂商以及运行环境等作出判断，满足不同生产环境的需求。</p>
<hr>
<h4 id="Ajax-的工作原理及优缺点"><a href="#Ajax-的工作原理及优缺点" class="headerlink" title="Ajax 的工作原理及优缺点"></a>Ajax 的工作原理及优缺点</h4><p><a href="https://www.cnblogs.com/mingmingruyuedlut/archive/2011/10/18/2216553.html" target="_blank" rel="external">https://www.cnblogs.com/mingmingruyuedlut/archive/2011/10/18/2216553.html</a></p>
<p>Ajax的原理简单来说就是通过XMLhttpRequest对象来想服务器发送异步请求，从服务器获得数据，然后用js来操作DOM实现局部更新页面的效果。</p>
<p>XMLhttpRequest是Ajax的核心机制，是一种支持异步请求的技术。也就是js可以及时向服务器提出请求和处理响应，而不阻塞用户，达到无刷新效果。</p>
<p>XMLhttpRequest对象的属性有：</p>
<ul>
<li>onreadystatechange  每次状态改变所触发事件的事件处理程序。</li>
<li>responseText     从服务器进程返回数据的字符串形式。</li>
<li>responseXML    从服务器进程返回的DOM兼容的文档数据对象。</li>
<li>status           从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）</li>
<li>status Text       伴随状态码的字符串信息</li>
<li><p>readyState       对象状态值</p>
<p>  0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）</p>
<p>  1 (初始化) 对象已建立，尚未调用send方法</p>
<p>  2 (发送数据) send方法已调用，但是当前的状态及http头未知</p>
<p>  3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，</p>
<p>  4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据</p>
</li>
</ul>
<p>由于浏览器之间的差异：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateXmlHttp</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//非IE浏览器创建XmlHttpRequest对象</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XmlHttpRequest) &#123;</div><div class="line">        xmlhttp = <span class="keyword">new</span> XmlHttpRequest();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//IE浏览器创建XmlHttpRequest对象</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            xmlhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (e) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                xmlhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"msxml2.XMLHTTP"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">catch</span> (ex) &#123; &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> 	&#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Ustbwuyi</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">document</span>.getElementById(<span class="string">"username"</span>).value;</div><div class="line">    CreateXmlHttp();</div><div class="line">    <span class="keyword">if</span> (!xmlhttp) &#123;</div><div class="line">        alert(<span class="string">"创建xmlhttp对象异常！"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    xmlhttp.open(<span class="string">"POST"</span>, url, <span class="literal">false</span>);</div><div class="line"></div><div class="line">    xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (xmlhttp.readyState == <span class="number">4</span>) &#123;</div><div class="line">            <span class="built_in">document</span>.getElementById(<span class="string">"user1"</span>).innerHTML = <span class="string">"数据正在加载..."</span>;</div><div class="line">            <span class="keyword">if</span> (xmlhttp.status == <span class="number">200</span>) &#123;</div><div class="line">                <span class="built_in">document</span>.write(xmlhttp.responseText);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    xmlhttp.send();&#125;</div></pre></td></tr></table></figure>
<p>知道了XMLHttpRequest的工作流程，我们可以看出，XMLHttpRequest是完全用来向服务器发出一个请求的，它的作用也局限于此，但它的作用是整个ajax实现的关键，因为ajax无非是两个过程，发出请求和响应请求。并且它完全是一种客户端的技术。而XMLHttpRequest正是处理了服务器端和客户端通信的问题所以才会如此的重要。</p>
<p><strong>优点</strong></p>
<ul>
<li>异步加载，良好的响应能力，不会打断用户的操作</li>
<li>减轻服务器的负担</li>
<li>无页面刷新，良好的用户体验</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>浏览器不兼容 - AJAX高度依赖JavaScript，而不同的浏览器对JavaScript支持性不同。这成了一个问题，尤其是当AJAX必须跨许多浏览器工作的时候。那些不支持JavaScript或者不支持JavaScript某些选项的浏览器将不能够正常使用ajax。由于ajax对JavaScript的依赖性，它不适用移动应用。你的web浏览器的后退键不能如期运行。</li>
<li>不安全性 - 网页可能很难调试，增加网页的代码量，你的网页更可能遇上严峻的安全威胁。</li>
<li>增加Web服务器的负载 - 如果你增加一个自动更新的功能，它每隔几秒向服务发起请求，那么就会增加服务器的负载。</li>
</ul>
<hr>
<h4 id="jsonp的工作原理，以及为什么不是ajax"><a href="#jsonp的工作原理，以及为什么不是ajax" class="headerlink" title="jsonp的工作原理，以及为什么不是ajax"></a>jsonp的工作原理，以及为什么不是ajax</h4><p><a href="https://zhuanlan.zhihu.com/p/30664364" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/30664364</a><br><a href="https://segmentfault.com/a/1190000007665361" target="_blank" rel="external">https://segmentfault.com/a/1190000007665361</a></p>
<hr>
<h4 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h4><p>handerlebars</p>
<hr>
<h4 id="“attribute”-和-“property”-的区别是什么？"><a href="#“attribute”-和-“property”-的区别是什么？" class="headerlink" title="“attribute” 和 “property” 的区别是什么？"></a>“attribute” 和 “property” 的区别是什么？</h4><p><a href="http://www.cnblogs.com/elcarim5efil/p/4698980.html" target="_blank" rel="external">http://www.cnblogs.com/elcarim5efil/p/4698980.html</a></p>
<p><code>attribute</code>保存了节点在html标签上从一开始设定的属性，他是一个Attr类型对象，拥有nodeType,nodeName等属性；打印attribute属性不会直接得到对象的值，而是获取一个包含属性名和值的字符串，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(in1.attibutes.sth);     <span class="comment">// 'sth="whatever"'</span></div></pre></td></tr></table></figure>
<p><img src="http://oy3ncu01s.bkt.clouddn.com/18-2-5/20522604.jpg" alt=""></p>
<p>DOM有其默认的基本属性，而这些属性就是所谓的“property”，无论如何，它们都会在初始化的时候再DOM对象上创建。如果在TAG对这些属性进行赋值，那么这些值就会作为初始值赋给DOM的同名property;下例中的value就是propoty属性，尽管没有赋值但是从一开始就存在。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(in2);</div><div class="line"><span class="comment">//id:'in'</span></div><div class="line"><span class="comment">//value:null</span></div></pre></td></tr></table></figure>
<p><code>propoty</code>与<code>attribute</code>是单向绑定的，property能够从attribute中得到同步；attribute不会同步property上的值；更改property和attribute上的任意值，都会将更新反映到HTML页面中；</p>
<hr>
<h4 id="为什么说扩展内置对象是个不好的做法"><a href="#为什么说扩展内置对象是个不好的做法" class="headerlink" title="为什么说扩展内置对象是个不好的做法"></a>为什么说扩展内置对象是个不好的做法</h4><hr>
<h4 id="请指出-document-load-和-document-DOMContentLoaded-两个事件的区别。"><a href="#请指出-document-load-和-document-DOMContentLoaded-两个事件的区别。" class="headerlink" title="请指出 document load 和 document DOMContentLoaded 两个事件的区别。"></a>请指出 document load 和 document DOMContentLoaded 两个事件的区别。</h4><p>当<code>onload</code>事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。</p>
<p>当<code>DOMContentLoaded</code>事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。</p>
<p>DOM文档加载的步骤为</p>
<ul>
<li>解析HTML结构。</li>
<li>加载外部脚本和样式表文件。</li>
<li>解析并执行脚本代码。</li>
<li>DOM树构建完成。//DOMContentLoaded</li>
<li>加载图片等外部文件。</li>
<li>页面加载完毕。//load</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="comment">// ...代码...</span></div><div class="line">&#125;, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...代码...</span></div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<hr>
<h4 id="和-有什么不同？"><a href="#和-有什么不同？" class="headerlink" title="== 和 === 有什么不同？"></a>== 和 === 有什么不同？</h4><p><code>==</code>两遍值类型不同时，先做类型变换再比较；</p>
<ul>
<li>如果类型相同，进行<code>===</code>比较</li>
<li><p>如果两个值类型不相同：</p>
<p>  1 <code>null == undefined</code>; <code>0 == &#39;&#39;</code>;</p>
<p>  2 一个是字符串一个是数值，就把字符串转成数值再比较 <code>1 = &quot;1&quot;</code></p>
<p>  3 <code>true</code>转换成数值1， <code>false</code>转化成0</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">	<span class="string">'1'</span> == <span class="literal">true</span> <span class="comment">//字符串转成数值1，true转成数值1</span></div><div class="line">	<span class="number">1</span> == <span class="literal">true</span> <span class="comment">//true转成数值1</span></div><div class="line">	<span class="string">``</span><span class="string">`	 </span></div><div class="line"><span class="string">	</span></div><div class="line"><span class="string">	4 对象转换成基础类型再比较（利用`</span>toString<span class="string">`,`</span>valueOf<span class="string">`）</span></div><div class="line"><span class="string">	</span></div><div class="line"><span class="string">`</span>===<span class="string">`严格等于，不做类型判断，直接比较，类型不同就不相同</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">---</span></div><div class="line"><span class="string">####  JavaScript 的同源策略 (same-origin policy)</span></div><div class="line"><span class="string">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">同源策略即三个相同：</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">* 协议相同</span></div><div class="line"><span class="string">* 端口相同</span></div><div class="line"><span class="string">* 域名相同</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">举例`</span>http<span class="comment">//www.example.com/dir/page.html`这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="http://www.example.com/dir2/other.html：同源" target="_blank" rel="external">http://www.example.com/dir2/other.html：同源</a><br><a href="https://www.example.com/dir2/other.html：不同源（协议不同）" target="_blank" rel="external">https://www.example.com/dir2/other.html：不同源（协议不同）</a><br><a href="http://v2.www.example.com/dir/other.html：不同源（域名不同）" target="_blank" rel="external">http://v2.www.example.com/dir/other.html：不同源（域名不同）</a><br><a href="http://www.example.com:81/dir/other.html：不同源（端口不同）" target="_blank" rel="external">http://www.example.com:81/dir/other.html：不同源（端口不同）</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">**目的**</div><div class="line"></div><div class="line">同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</div><div class="line"></div><div class="line">&quot;同源政策&quot;是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</div><div class="line"></div><div class="line">**限制范围**</div><div class="line"></div><div class="line">（1）Cookie、LocalStorage 和 IndexDB 无法读取。</div><div class="line"></div><div class="line">（2） DOM 无法获得。</div><div class="line"></div><div class="line">（3） AJAX 请求不能发送。</div><div class="line"></div><div class="line">**window.postMessage**</div><div class="line"></div><div class="line">**ajax跨域问题**</div><div class="line"></div><div class="line">* 服务器代理</div><div class="line">* jsonp</div><div class="line">* websocket</div><div class="line">* cors</div><div class="line"></div><div class="line">---</div><div class="line">#### 浅拷贝、深拷贝</div><div class="line">https://segmentfault.com/a/1190000008637489</div><div class="line">https://github.com/wengjq/Blog/issues/3</div><div class="line"></div><div class="line">&gt; JavaScript存储对象都是存地址的，所以浅拷贝会导致 obj1 和obj2 指向同一块内存地址。改变了其中一方的内容，都是在原来的内存上做修改会导致拷贝对象和源对象都发生改变，而深拷贝是开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作互不影响。</div><div class="line"></div><div class="line">**变量类型**</div><div class="line"></div><div class="line">（1）基本类型：5中基本类型undefined，null,boolean,number,string，变量是直接按值存放在栈内存中的简单数据段，可以直接访问</div><div class="line"></div><div class="line">（2）引用类型：存放在堆内存中的对象，变量保存的是一个指针，当需要访问引用类型（如对象，数组）的值是，首先从栈中获得该对象的地址指针，再从堆内存中去的所需的数据。</div><div class="line"></div><div class="line">**浅拷贝**：拷贝原对象的引用</div><div class="line">```js</div><div class="line">// 对象</div><div class="line">var o1 = &#123;a: 1&#125;;</div><div class="line">var o2 = o1;</div><div class="line"></div><div class="line">console.log(o1 === o2);  // =&gt;true</div><div class="line">o2.a = 2; </div><div class="line">console.log(o1.a); // =&gt; 2 对象是引用类型，属于可变对象</div><div class="line"></div><div class="line">// 数组</div><div class="line">var o1 = [1,2,3];</div><div class="line">var o2 = o1;</div><div class="line"></div><div class="line">console.log(o1 === o2); // =&gt; true</div><div class="line">o2.push(4);</div><div class="line">console.log(o1); // =&gt; [1,2,3,4]</div></pre></td></tr></table></figure></p>
<p><code>array,prototype.slice()</code>和<code>array.prototype.concat()</code>都会返回数组或对象的浅拷贝</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="number">01</span> = [<span class="string">'adrk'</span>,&#123;<span class="attr">age</span>:<span class="number">22</span>&#125;];</div><div class="line"><span class="keyword">var</span> o2 = o1.slice();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o1 === o2);		<span class="comment">//false 说明o2拷贝的是o1的一个实例</span></div><div class="line"></div><div class="line">o2[<span class="number">0</span>] = <span class="string">'lee'</span>;</div><div class="line"><span class="built_in">console</span>.log(o1[<span class="number">0</span>]); <span class="comment">// =&gt; "darko" o1和o2内部包含的基本类型值，复制的是其实例，不会相互影响</span></div><div class="line"></div><div class="line">o2[<span class="number">1</span>].age = <span class="number">23</span>;</div><div class="line"><span class="built_in">console</span>.log(o1[<span class="number">1</span>].age); <span class="comment">// =&gt;23 o1和o2内部包含的引用类型值，复制的是其引用，会相互影响</span></div></pre></td></tr></table></figure>
<p><strong>深拷贝</strong> 拷贝实例，新的实例和之前的实例互不影响</p>
<p>还有一种实现深拷贝的方式是利用JSON对象中的parse和stringify，JOSN对象中的stringify可以把一个js对象序列化为一个JSON字符串，parse可以把JSON字符串反序列化为一个js对象，通过这两个方法，也可以实现对象的深复制。</p>
<hr>
<h4 id="严格模式好处及坏处"><a href="#严格模式好处及坏处" class="headerlink" title="严格模式好处及坏处"></a>严格模式好处及坏处</h4><p><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html</a></p>
<hr>
<h4 id="请实现一个遍历至-100-的-for-loop-循环，在能被-3-整除时输出-“fizz”，在能被-5-整除时输出-“buzz”，在能同时被-3-和-5-整除时输出-“fizzbuzz”。"><a href="#请实现一个遍历至-100-的-for-loop-循环，在能被-3-整除时输出-“fizz”，在能被-5-整除时输出-“buzz”，在能同时被-3-和-5-整除时输出-“fizzbuzz”。" class="headerlink" title="请实现一个遍历至 100 的 for loop 循环，在能被 3 整除时输出 “fizz”，在能被 5 整除时输出 “buzz”，在能同时被 3 和 5 整除时输出 “fizzbuzz”。"></a>请实现一个遍历至 100 的 for loop 循环，在能被 3 整除时输出 “fizz”，在能被 5 整除时输出 “buzz”，在能同时被 3 和 5 整除时输出 “fizzbuzz”。</h4><hr>
<h4 id="为何通常会认为保留网站现有的全局作用域-global-scope-不去改变它，是较好的选择？"><a href="#为何通常会认为保留网站现有的全局作用域-global-scope-不去改变它，是较好的选择？" class="headerlink" title="为何通常会认为保留网站现有的全局作用域 (global scope) 不去改变它，是较好的选择？"></a>为何通常会认为保留网站现有的全局作用域 (global scope) 不去改变它，是较好的选择？</h4><hr>
<h4 id="为何你会使用-load-之类的事件-event-？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？"><a href="#为何你会使用-load-之类的事件-event-？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？" class="headerlink" title="为何你会使用 load 之类的事件 (event)？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？"></a>为何你会使用 load 之类的事件 (event)？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？</h4><p><a href="http://horve.github.io/2015/10/17/domcontentloaded/" target="_blank" rel="external">http://horve.github.io/2015/10/17/domcontentloaded/</a></p>
<p>页面加载完后执行，用户体验差；</p>
<ol>
<li><p>Jquery的<code>$(&quot;document&quot;).ready()</code>;</p>
</li>
<li><p>DOMContentLoaded事件</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( <span class="built_in">document</span>.addEventListener ) &#123;</div><div class="line">    <span class="built_in">document</span>.addEventListener( <span class="string">"DOMContentLoaded"</span>, completed, <span class="literal">false</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="请解释什么是单页应用-single-page-app-以及如何使其对搜索引擎友好-SEO-friendly-。"><a href="#请解释什么是单页应用-single-page-app-以及如何使其对搜索引擎友好-SEO-friendly-。" class="headerlink" title="请解释什么是单页应用 (single page app), 以及如何使其对搜索引擎友好 (SEO-friendly)。"></a>请解释什么是单页应用 (single page app), 以及如何使其对搜索引擎友好 (SEO-friendly)。</h4><p>先解释下传统的MVC框架：</p>
<blockquote>
<p>全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码</p>
</blockquote>
<p>传统的网页应用中，浏览器充当展示层，路由处理、服务调用、页面跳转都由服务器端来处理。即MVC都放在放在服务器端，而V（视图）作为用户界面则通过网络发送到浏览器端，作为UI与用户交互。</p>
<p><img src="http://oy3ncu01s.bkt.clouddn.com/18-2-7/17444265.jpg" alt=""></p>
<p>有以下特点：</p>
<ul>
<li>重服务端，由于 MVC 都存在于服务器上，因此这类应用在开发资源和开发的重心都偏向后端，往往是后端工程师来主导整个项目开发；</li>
<li>页面频繁刷新，由于浏览器端只是一个展现层，当页面功能有所变化的时，页面就刷新，这会导致资源的浪费，用户需要花费额外的时间等待页面刷新，用户体验不佳。</li>
</ul>
<p><strong>单页应用</strong><br>相对于传统页面，单页面应用MVC前置了浏览器前端：</p>
<p><img src="http://oy3ncu01s.bkt.clouddn.com/18-2-7/78699006.jpg" alt=""></p>
<ul>
<li>控制器前置 单页应用将路由处理放在浏览器端，即在浏览器端直接响应浏览器地址的变化，分发到对应的路由，向用户呈现相应的界面。</li>
<li>以小块组件为功能原件 再路由变化时，不在刷新整个页面，而是只变更变化的部分，达到节约资源的目的</li>
<li>数据层前置，与 Ajax 组件一个明显的区别是，单页应用在浏览器端通常有一层实实在在的数据层，而服务端则退化成了完全的数据 API。浏览器端的数据层会封装服务端 API，供上层的视图层调用。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>无刷新体验，这个应该是最显著的有点，由于路由分发直接在浏览器端完成，页面是不刷新，对用户的响应非常及时，因此提升了用户体验；</li>
<li>完全的前端组件化，前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方式更加规范化，便于修改和调整；</li>
<li>组件共享，在某些对性能体验要求不高的场景，或者产品处于快速试错阶段，借助于一些技术（Hybrid、React Native），可以在多端共享组件，便于产品的快速迭代，节约资源。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>首次加载大量资源 要在一个页面上为用户提供产品的所有功能，在这个页面加载的时候，首先要加载大量的静态资源，这个加载时间相对比较长；</li>
<li>较高的开发门槛 </li>
<li>不利于SEO 单页页面，数据在前端渲染，就意味着没有 SEO，或者需要使用变通的方案。</li>
</ul>
<p><strong>单页面应用SEO</strong></p>
<p><a href="http://www.ruanyifeng.com/blog/2013/07/how_to_make_search_engines_find_ajax_content.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/07/how_to_make_search_engines_find_ajax_content.html</a></p>
<p><a href="https://ziyuan.baidu.com/college/articleinfo?id=294" target="_blank" rel="external">https://ziyuan.baidu.com/college/articleinfo?id=294</a></p>
<p><img src="http://oy3ncu01s.bkt.clouddn.com/18-2-7/36694851.jpg" alt=""></p>
<hr>
<h4 id="使用一种可以编译成-JavaScript-的语言来写-JavaScript-代码有哪些优缺点？"><a href="#使用一种可以编译成-JavaScript-的语言来写-JavaScript-代码有哪些优缺点？" class="headerlink" title="使用一种可以编译成 JavaScript 的语言来写 JavaScript 代码有哪些优缺点？"></a>使用一种可以编译成 JavaScript 的语言来写 JavaScript 代码有哪些优缺点？</h4><hr>
<h4 id="你使用哪些工具和技术来调试-JavaScript-代码？"><a href="#你使用哪些工具和技术来调试-JavaScript-代码？" class="headerlink" title="你使用哪些工具和技术来调试 JavaScript 代码？"></a>你使用哪些工具和技术来调试 JavaScript 代码？</h4><p><a href="http://wiki.jikexueyuan.com/project/chrome-devtools/debugging-javascript.html" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/chrome-devtools/debugging-javascript.html</a></p>
<p><a href="https://segmentfault.com/a/1190000011857058" target="_blank" rel="external">https://segmentfault.com/a/1190000011857058</a></p>
<hr>
<h4 id="你会使用怎样的语言结构来遍历对象属性-object-properties-和数组内容？"><a href="#你会使用怎样的语言结构来遍历对象属性-object-properties-和数组内容？" class="headerlink" title="你会使用怎样的语言结构来遍历对象属性 (object properties) 和数组内容？"></a>你会使用怎样的语言结构来遍历对象属性 (object properties) 和数组内容？</h4><p><a href="http://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/iterator</a></p>
<ul>
<li>任何数据结构只要部署 Iterator 接口，就可以完成遍历操作</li>
</ul>
<p><img src="http://oy3ncu01s.bkt.clouddn.com/18-2-7/15467394.jpg" alt=""></p>
<p><img src="http://oy3ncu01s.bkt.clouddn.com/18-2-7/27858714.jpg" alt=""></p>
<ul>
<li><code>for...of</code></li>
<li><code>for...in</code></li>
<li><code>foreach</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(e);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<hr>
<h4 id="请解释可变-mutable-和不变-immutable-对象的区别。不变性-immutability-有哪些优缺点？如何用你自己的代码来实现不变性-immutability-？"><a href="#请解释可变-mutable-和不变-immutable-对象的区别。不变性-immutability-有哪些优缺点？如何用你自己的代码来实现不变性-immutability-？" class="headerlink" title="请解释可变 (mutable) 和不变 (immutable) 对象的区别。不变性 (immutability) 有哪些优缺点？如何用你自己的代码来实现不变性 (immutability)？"></a>请解释可变 (mutable) 和不变 (immutable) 对象的区别。不变性 (immutability) 有哪些优缺点？如何用你自己的代码来实现不变性 (immutability)？</h4><p><a href="http://www.cnblogs.com/Ziksang/p/5203551.html" target="_blank" rel="external">http://www.cnblogs.com/Ziksang/p/5203551.html</a></p>
<p><strong><a href="http://laichuanfeng.com/study/javascript-immutable-primitive-values-and-mutable-object-references/" target="_blank" rel="external">http://laichuanfeng.com/study/javascript-immutable-primitive-values-and-mutable-object-references/</a></strong></p>
<p>JavaScript 中的原始值（undefained、null、布尔值、数字和字符串）与引用值（对象，数组，函数等）有着根本的区别。</p>
<p><strong>存储方式</strong></p>
<blockquote>
<p>原始值</p>
</blockquote>
<p>存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。</p>
<blockquote>
<p>引用值</p>
</blockquote>
<p>存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。</p>
<p>原始数据类型都是不可变的原始值，任何操作都不能改变他，只会返回一个新的值，或是给相应的变量赋给一个新的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">"hello"</span>; <span class="comment">//定义一个由小写字母组成字符串</span></div><div class="line">s.toUpperCase(); <span class="comment">//=&gt;“HELLO”，但并没有改变s的值</span></div><div class="line">s;               <span class="comment">//=&gt;“hello”：原始字符串的值并未改变。</span></div></pre></td></tr></table></figure>
<p><strong>原始值的比较是值的比较</strong>：只有在它们的值相等时它们才相等。这对数字、布尔值、null和underfined来说听起来有点难懂，并没有其他办法来比较他们。同样，对于字符串来说则并不明显：如果比较两个单独的字符串，当且仅当他们的长度相等且每个索引的字符都相等时，JavaScript 才认为它们相等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="string">'str'</span>;</div><div class="line"><span class="keyword">var</span> arr2 = arr;</div><div class="line"><span class="built_in">console</span>.log(arr === arr2);		<span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><strong>引用值的比较并非值的比较</strong>：即使两个引用值包含同样的属性及相同的值，它们也是不相等的。各个索引元素完全相等的两个数组也不相等；我们通常将对象称为引用类型（reference type)，以此来和 JavaScript 的基本类型区分开来。依照术语的叫法，对象值都是引用（reference），对象的比较均是引用的比较：当且仅当它们引用同一个基对象时，它们才相等。并且，修改引用值时，基对象也会被修改（对象的浅拷贝）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = []; <span class="comment">//定义一个引用空数组的变量a</span></div><div class="line"><span class="keyword">var</span> b = a;  <span class="comment">//变量b引用同一个数组</span></div><div class="line">b[<span class="number">0</span>] = <span class="number">1</span>;   <span class="comment">//通过变量b来修改引用的数组</span></div><div class="line">a[<span class="number">0</span>];       <span class="comment">//=&gt; 1：变量a也会被修改</span></div><div class="line">a === b;    <span class="comment">//=&gt; true：a和b引用同一个数组，因此它们相同</span></div></pre></td></tr></table></figure>
<hr>
<h4 id="阻塞I-O，非阻塞I-O"><a href="#阻塞I-O，非阻塞I-O" class="headerlink" title="阻塞I/O，非阻塞I/O"></a>阻塞I/O，非阻塞I/O</h4><p><strong>同步IO和异步IO，它指的是应用程序和操作系统内核间的关系。</strong></p>
<p>现代主流的两种资源分配方式：</p>
<ul>
<li>单线程串行依次执行； 易造成I/O阻塞</li>
<li>多线程并行执行 多线程的代价在于创建线程和执行期线程上下文切换的开销较大。</li>
</ul>
<p>阻塞I/O调用结果返回之前，当前线程会被挂起，特点是调用之后一定要等到系统内核层面完成所有操作之后，调用才结束。易造成CPU等待I/O，浪费等待时间，CPU处理能力得不到发挥。</p>
<p><img src="http://oy3ncu01s.bkt.clouddn.com/18-2-7/49380815.jpg" alt=""></p>
<p>非阻塞I/O指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。不带数据直接返回，但非阻塞i/o也存在一些问题：由于事件进程并未完成，需要重复调用I/O操作来确认是否完成。这种重复确认操作是否完成的技术叫做<strong>轮询</strong>。</p>
<p><img src="http://oy3ncu01s.bkt.clouddn.com/18-2-7/74930949.jpg" alt=""></p>
<hr>
<h4 id="请解释同步-synchronous-和异步-asynchronous-函数的区别。"><a href="#请解释同步-synchronous-和异步-asynchronous-函数的区别。" class="headerlink" title="请解释同步 (synchronous) 和异步 (asynchronous) 函数的区别。"></a>请解释同步 (synchronous) 和异步 (asynchronous) 函数的区别。</h4><p>见博客</p>
<hr>
<h4 id="事件循环？调用栈和任务队列的区别"><a href="#事件循环？调用栈和任务队列的区别" class="headerlink" title="事件循环？调用栈和任务队列的区别"></a>事件循环？调用栈和任务队列的区别</h4><p>调用栈是主线程上形成的执行栈，函数的执行就是同步的进栈与出栈的过程。</p>
<p>异步任务不直接进入主线程，而是进入任务队列，当‘任务对列’通知主线程某个异步任务可以执行时，该任务才会进入主线程执行。</p>
<p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p>

      
    </div>
    
    
    

    
     
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/js/" rel="tag"># js</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/20/css面经积累/" rel="next" title="css面经积累">
                <i class="fa fa-chevron-left"></i> css面经积累
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/02/html面经积累/" rel="prev" title="html面经积累">
                html面经积累 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="ycccheng" />
          <p class="site-author-name" itemprop="name">ycccheng</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#一些判断"><span class="nav-number">1.</span> <span class="nav-text">一些判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for…in-和-for…of-的区别"><span class="nav-number">2.</span> <span class="nav-text">for…in 和 for…of 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rest参数"><span class="nav-number">3.</span> <span class="nav-text">rest参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变量提升"><span class="nav-number">4.</span> <span class="nav-text">变量提升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#名字空间"><span class="nav-number">5.</span> <span class="nav-text">名字空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#let-const"><span class="nav-number">6.</span> <span class="nav-text">let const</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解构赋值"><span class="nav-number">7.</span> <span class="nav-text">解构赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#apply和call"><span class="nav-number">8.</span> <span class="nav-text">apply和call</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#箭头函数的this"><span class="nav-number">9.</span> <span class="nav-text">箭头函数的this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件代理-委托"><span class="nav-number">10.</span> <span class="nav-text">事件代理/委托</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请解释-JavaScript-中-this-是如何工作的"><span class="nav-number">11.</span> <span class="nav-text">请解释 JavaScript 中 this 是如何工作的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bind方法"><span class="nav-number">12.</span> <span class="nav-text">bind方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#你怎么看-AMD-vs-CommonJS"><span class="nav-number">13.</span> <span class="nav-text">你怎么看 AMD vs. CommonJS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IIFE立即执行函数表达式"><span class="nav-number">14.</span> <span class="nav-text">IIFE立即执行函数表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#null，undefined-或-undeclaredd的区别"><span class="nav-number">15.</span> <span class="nav-text">null，undefined 或 undeclaredd的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？"><span class="nav-number">16.</span> <span class="nav-text">你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-宿主对象-host-objects-和原生对象-native-objects-、内置对象-？"><span class="nav-number">17.</span> <span class="nav-text">JavaScript 宿主对象 (host objects) 和原生对象 (native objects)、内置对象 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数表达式与函数声明"><span class="nav-number">18.</span> <span class="nav-text">函数表达式与函数声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在什么时候你会使用-document-write-？"><span class="nav-number">19.</span> <span class="nav-text">在什么时候你会使用 document.write()？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请指出浏览器特性检测，特性推断和浏览器-UA-字符串嗅探的区别"><span class="nav-number">20.</span> <span class="nav-text">请指出浏览器特性检测，特性推断和浏览器 UA 字符串嗅探的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ajax-的工作原理及优缺点"><span class="nav-number">21.</span> <span class="nav-text">Ajax 的工作原理及优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jsonp的工作原理，以及为什么不是ajax"><span class="nav-number">22.</span> <span class="nav-text">jsonp的工作原理，以及为什么不是ajax</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模板引擎"><span class="nav-number">23.</span> <span class="nav-text">模板引擎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#“attribute”-和-“property”-的区别是什么？"><span class="nav-number">24.</span> <span class="nav-text">“attribute” 和 “property” 的区别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么说扩展内置对象是个不好的做法"><span class="nav-number">25.</span> <span class="nav-text">为什么说扩展内置对象是个不好的做法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请指出-document-load-和-document-DOMContentLoaded-两个事件的区别。"><span class="nav-number">26.</span> <span class="nav-text">请指出 document load 和 document DOMContentLoaded 两个事件的区别。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#和-有什么不同？"><span class="nav-number">27.</span> <span class="nav-text">== 和 === 有什么不同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#严格模式好处及坏处"><span class="nav-number">28.</span> <span class="nav-text">严格模式好处及坏处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请实现一个遍历至-100-的-for-loop-循环，在能被-3-整除时输出-“fizz”，在能被-5-整除时输出-“buzz”，在能同时被-3-和-5-整除时输出-“fizzbuzz”。"><span class="nav-number">29.</span> <span class="nav-text">请实现一个遍历至 100 的 for loop 循环，在能被 3 整除时输出 “fizz”，在能被 5 整除时输出 “buzz”，在能同时被 3 和 5 整除时输出 “fizzbuzz”。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为何通常会认为保留网站现有的全局作用域-global-scope-不去改变它，是较好的选择？"><span class="nav-number">30.</span> <span class="nav-text">为何通常会认为保留网站现有的全局作用域 (global scope) 不去改变它，是较好的选择？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为何你会使用-load-之类的事件-event-？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？"><span class="nav-number">31.</span> <span class="nav-text">为何你会使用 load 之类的事件 (event)？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请解释什么是单页应用-single-page-app-以及如何使其对搜索引擎友好-SEO-friendly-。"><span class="nav-number">32.</span> <span class="nav-text">请解释什么是单页应用 (single page app), 以及如何使其对搜索引擎友好 (SEO-friendly)。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用一种可以编译成-JavaScript-的语言来写-JavaScript-代码有哪些优缺点？"><span class="nav-number">33.</span> <span class="nav-text">使用一种可以编译成 JavaScript 的语言来写 JavaScript 代码有哪些优缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#你使用哪些工具和技术来调试-JavaScript-代码？"><span class="nav-number">34.</span> <span class="nav-text">你使用哪些工具和技术来调试 JavaScript 代码？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#你会使用怎样的语言结构来遍历对象属性-object-properties-和数组内容？"><span class="nav-number">35.</span> <span class="nav-text">你会使用怎样的语言结构来遍历对象属性 (object properties) 和数组内容？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请解释可变-mutable-和不变-immutable-对象的区别。不变性-immutability-有哪些优缺点？如何用你自己的代码来实现不变性-immutability-？"><span class="nav-number">36.</span> <span class="nav-text">请解释可变 (mutable) 和不变 (immutable) 对象的区别。不变性 (immutability) 有哪些优缺点？如何用你自己的代码来实现不变性 (immutability)？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞I-O，非阻塞I-O"><span class="nav-number">37.</span> <span class="nav-text">阻塞I/O，非阻塞I/O</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请解释同步-synchronous-和异步-asynchronous-函数的区别。"><span class="nav-number">38.</span> <span class="nav-text">请解释同步 (synchronous) 和异步 (asynchronous) 函数的区别。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件循环？调用栈和任务队列的区别"><span class="nav-number">39.</span> <span class="nav-text">事件循环？调用栈和任务队列的区别</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ycccheng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
