<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js面经积累]]></title>
    <url>%2F2018%2F01%2F23%2Fjs%E9%9D%A2%E7%BB%8F%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[一些判断 typeof操作符可以判断number,boolean,string,function,undefined; 判断array需要用array.isArray(arr); 判断null需要用myVar === null; 判断某个全局变量是否存在使用typeof window.myVar === &#39;undefined&#39;; 函数内部判断某个变量是否存在用typeof myVar === &#39;undefined&#39; for…in 和 for…of 的区别for...in由于历史遗留问题，它的遍历实际上是对象属性的遍历，一个array数组实际上也是一个对象，对象属性即是数据的索引 1234var arr = [1,2,3];for(var x in arr)&#123; console.log(x); //0,1,2&#125; for...of循环则完全修复了这些问题，它只循环集合本身的元素： 12345var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x of a) &#123; console.log(x); // 'A', 'B', 'C'&#125; rest参数es6引入rest参数，为了获得额外的参数 12345678910function foo(a, b, ...rest) &#123; console.log('a = ' + a); console.log('b = ' + b); console.log(rest);&#125;foo(1, 2, 3, 4, 5);// a = 1 b = 2 Array [ 3, 4, 5 ]foo(1);//a = 1 b = undefined Array [] 变量提升函数定义有个特点，他会先扫描整个函数体的语句，把所有声明的变量提升到函数顶部 123456function foo() &#123; var x = 'Hello, ' + y; console.log(x); var y = 'Bob';&#125;foo(); //hello,unddefined 上函数体内的第一句并不会报错，因为y变量在后面已经声明了，但函数尚未运行到该句，所以y此时是undefined 由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量 名字空间全局变量会绑定到window上，不同的js文件如果使用了相同的全局变量，或者定义了相同的顶层函数，都会造成命名冲突。减少这种冲突的方法就是把自己的所有变量和函数全部绑定到一个全局变量中。 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return 'foo';&#125;; let constlet用来声明变量，与var类似。但let声明的变量只在所在的代码块中有效。 为了纠正var变量提升的现象，let声明的变量不存在变量提升，所有的变量必须在声明后使用。如果在变量声明之前调用，则会报错，语法上称为‘暂时性死区’。 const声明一个只读的常量。一旦声明，常量的值就不能改变。并且只在块级作用域中有效。也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 解构赋值从数组和对象中提取值，对变量进行赋值，这被称为解构,属于模式匹配。并允许指定默认值 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 对象的解构赋值与数组不同，对象的解构必须属性名一致。 123456let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let &#123; foo: baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // "aaa"foo // error: foo is not defined 字符串的解构赋值是把字符串转化成了类似于数组的对象 12const [a,b,c,d,e] = 'hello';a; //'h' 数值和布尔值的解构赋值是先将数值和布尔值转化成对象 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true apply和call两者都是用来引入另一个对象的方法，或是用另一个对象替换当前的对象。 123B.apply(A,[argument1, argument2]);//A对象调用B对象的方法B.apply(A,argument1, argument2);//A对象调用B对象的方法//都将B对象的this指向A 唯一区别：传入参数的表示形式不同 apply()把参数打包成Array再传入； call()把参数按顺序传入。 箭头函数的this箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数内部的this是词法作用域，由上下文确定。比较下面两个例子 1234567891011var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = function () &#123; return new Date().getFullYear() - this.birth; // this指向window或undefined,通过var that = this来修正this的指向。 &#125;; return fn(); &#125;&#125;; 箭头函数修复了this的指向问题，指向词法作用域。 123456789var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); &#125;&#125;;obj.getAge(); // 25]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css面经积累]]></title>
    <url>%2F2018%2F01%2F20%2Fcss%E9%9D%A2%E7%BB%8F%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[置换元素一个内容，不受CSS视觉格式化模型控制，CSS渲染模型并不考虑对此内容的渲染，一般都拥有固定尺寸（宽度、高度、高度比）的元素，称为置换元素。 例如浏览器会根据img的src属性值来读取图片信息并显示出来；又如根据input的type属性来决定是显示文本还是按钮等。 常见的替换元素有img input textarea select object。 行内元素、块状元素常见的块状元素有：div p form ul ol 常见的行内元素有：span strong em 区别 块状元素独占一行且宽度回沾满父元素的宽度，行内元素不会独占一行，且相邻元素可以同在一行。 块状元素可以设置宽高，且还是会独占一行；行内元素设置宽高无效。 块状元素可以设置margin padding属性；行内元素水平方向的margin padding属性，但是垂直方向不会产生边距效果。 块状元素对应的display:block,行内元素display:inline,display:inline-block属性可以让元素具有块状元素和行内元素特性：既可以设置宽高、设置边距、也可以与其他元素并排。 CSS 中类 (classes) 和 ID 的区别。 书写上的差别：class名用“.”号开头来定义，id名用“#”号开头来定义； 调用上的区别：在同一个html网页页面中class是可以被多次调用的（在不同的地方）。而id名作为标签的身份则是唯一的，id在页面中只能出现一次。在js脚本中经常会用到id来修改一个标签的属性 id是先找到结构/内容，再给它定义样式；class是先定义好一种样式，再套给多个结构/内容。 请问 “resetting” 和 “normalizing” CSS 之间的区别？你会如何选择，为什么？http://jerryzou.com/posts/aboutNormalizeCss/ Normalize.css 保护了有价值的默认值Reset通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。相比之下，Normalize.css保持了许多默认的浏览器样式。这就意味着你不用再为所有公共的排版元素重新设置样式。 请解释浮动 (Floats) 及其工作原理。先来说一下标准文档流这个概念，浏览器在解析过程中，会遵循从上到下、从左到右的顺序，这个顺序就是来源于标准文档流。所有的块状元素独占一行，自上到下；所有的行内元素从左到右，不换行。下图就是标准文档流，自上到下排列。 https://www.cnblogs.com/iyangyuan/archive/2013/03/27/2983813.html 如果想要让块状元素及行内元素改变原先的状态，除了display以外，还可以用float,position属性让元素脱离文档流。 浮动可以理解为让某个div脱离文档流，漂浮在标准流之上，和标准流不在一个层次上。 div2设置了浮动，div1,div3,div4仍在标准流中，所以div3自动向上移动，占据div2的位置，重新组成一个流。 上图div2，div3同时左浮动，div4上移，组成一个新的标准流，div2,div3浮动在标准流之上，因此div2遮挡住了div4. 清除浮动 clear:none | left | right | both 允许两边都可以浮动 | 不允许左浮动 | 不允许右浮动 | 不允许浮动 对于CSS的清除浮动(clear)，一定要牢记：这个规则只能影响使用清除的元素本身，不能影响其他元素。 描述z-index和叠加上下文是如何形成的。https://www.cnblogs.com/starof/p/4424926.html 先解释一个名词，“堆叠上下文”，每个元素仅属于一个堆叠上下文，元素的z-index在相同的堆叠上下文中按‘z轴’的顺序呈现。 默认情况 默认情况就是所有的元素都不使用z-index,堆叠顺序如下： 根元素的background和border 正常流中非定位的元素，会先于定位元素渲染，总是在定位元素的下方，如下图中的div5。 没有z-index的定位元素，他们的堆叠顺序取决于在html文档中的顺序，越靠后的元素，位置越高，与position属性无关。 上图渲染顺序为5&gt;1&gt;2&gt;3&gt;4 浮动元素堆叠 浮动元素堆叠位置位于非定位与定位元素之间 根元素的background和border 正常流中非定位的元素，会先于定位元素渲染，总是在定位元素的下方。 浮动元素 已定位的元素。 上图中，#4是正常流中元素，位于最底层；#2，#3是浮动元素，接着被渲染，彼此不会因为z-index而堆叠覆盖；#1，#5是定位元素，最后渲染，按出现顺序堆叠。渲染顺序为4&gt;2&gt;3&gt;1&gt;5。 z-index堆叠z-index只适合已经定位的元素，元素按z-indexD的值堆叠 在堆叠上下文中，子元素与父元素的堆叠上下文独立开来，互补影响。看下图。 为什么#4的z-index比#1高却在#1的下面呢？因为#4的z-index的值大，但他的作用域包含在#3内，而#1的z-index的作用域在html内，和#3同属html，而#3的z-index小于#1。同理#2在#5的下面。 `#3的z-index是4，但该值和#4,#5,#6的z-index不具有可比性，它们不在一个上下文环境。 如何轻易的判断两个元素的堆叠顺序？ Root-z-index值为默认auto，即0 DIV #2 - z-index 值为2 DIV #3 - z-index 值为4 DIV #5 - z-index值为 1,其父元素z-index值 4,所以最终值为4.1 DIV #6 - z-index值为 3,其父元素z-index值 4,所以最终值为4.3 DIV #4 - z-index值为 6,其父元素z-index值 4,所以最终值为4.6 DIV #1 - z-index 值为5 请描述 BFC(Block Formatting Context) 及其如何工作box是css布局的基本单位，一个页面就是由很多个box组成的。元素的类型和display属性决定了这个box的类型。不同类型的box,会参与到不同的Foomating Context（一个决定如何渲染文档的容器）中。 BFC：box-level box : display属性为blocak``list-item``table的元素，会生成box-level box,并参与BFC IFC： inline-level-box:display属性为inline``inline-block``inline-table的元素，会生成inline-level box,且参与到IEC。 Foomating Context 他是页面中的一块渲染区域，并且有一套渲染规则，他决定了其子元素将如何定位，以及和其他相邻元素的相互作用。 BFC块级格式化上下文 是一个独立的渲染区域，只有block-level box参与，规定了内部的block-level box如何布局，并且与区域外部不相干 布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 哪些元素会产生BFC 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible 123&lt;div style="border: 1px solid #000;"&gt; &lt;div style="width: 100px;height: 100px;background: #eee;float: left;"&gt;&lt;/div&gt;&lt;/div&gt; 由于float属性，脱离了文档流，容器只剩下2px的边距高度。如果触发容器的BFC，那么容器就会包裹浮动元素。常见的是使用overflow:hidden属性。 123&lt;div style="border: 1px solid #000;overflow: hidden"&gt; &lt;div style="width: 100px;height: 100px;background: #eee;float: left;"&gt;&lt;/div&gt;&lt;/div&gt; 清楚浮动https://www.jianshu.com/p/09bd5873bed4包裹性：给物体添加外层容器将其隔绝起来，且内部变动对外部不造成影响，形成BFC。破坏性：没有高度属性的容器使用float的子元素会造成父元素塌陷(!!!没有高度的父容器)， 在浮动元素后加一个clear:both：在被清除浮动的元素上边或者下边添加足够的清除空间 123456&lt;div class="box-wrapper"&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div style="clear:both;"&gt;&lt;/div&gt;&lt;/div&gt; 2.clear-fix 推荐！！！利用伪元素 1234567891011121314// 全浏览器通用的clearfix方案【推荐】// 引入了zoom以支持IE6/7// 同时加入:before以解决现代浏览器上边距折叠的问题.clearfix:before,.clearfix:after &#123; display: table; content: " ";&#125;.clearfix:after &#123; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125; 3.BFC 123.box-wrapper&#123; overflow: hidden;&#125; 请解释 CSS sprites，以及你要如何在页面或网站中实现它CSS sprite即把网页中比较小的一些小图片整合到一张图片文件中，再利用CSS的background-image属性插入图片，然后利用background-position属性对图片所需要的部分进行精确定位，从而达到减少服务器请求次数的目的。 图片替换方法http://nicolasgallagher.com/css-image-replacement-with-pseudo-elements/ http://blog.csdn.net/cwzhsi/article/details/46403077 你会如何解决特定浏览器的样式问题 如何为有功能限制的浏览器提供网页？渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 相关技术:Media QueryCSS hack条件判断&lt;! –[if !IE]&gt;除IE外都可识别 有哪些的隐藏内容的方法 (如果同时还要保证屏幕阅读器可用呢)？ display:none搜索引擎可能认为被隐藏的是垃圾信息而被忽略，屏幕阅读器（是为视觉上有障碍的人设计的读取屏幕内容的程序）会忽略被隐藏的文字 visibility:hidden：隐藏的内容会占据物理空间。即内容虽被隐藏，但是文档流的位置会出现空白 overflow:hidden 123456.div&#123; display:block //转化成块状元素 overflow:hidden height:0 width:0 //宽高设为0，超出的部分隐藏&#125; 你用过栅格系统 (grid system) 吗？如果使用过，你最喜欢哪种？bootstrp栅格系统响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。 http://v3.bootcss.com/css/#grid-example-fluid 123456789101112131415&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-8&quot;&gt;.col-md-8&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt; &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 你用过媒体查询，或针对移动端的布局/CSS 吗？https://www.ibm.com/developerworks/cn/web/wa-cssqueries/index.html 响应式设计的一种方法 你熟悉 SVG 样式的书写吗？ 如何优化网页的打印样式？http://blog.csdn.net/xujie_0311/article/details/42271273https://www.cnblogs.com/huashanqingzhu/p/4345698.html 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;xxx.css&quot; /&gt; 其中media指定的属性就是设备，显示器上就是screen，打印机则是print，电视是tv，投影仪是projection。 但打印样式表也应有些注意事项： 1、打印样式表中最好不要用背景图片，因为打印机不能打印CSS中的背景。如要显示图片，请使用html插入到页面中。 2、最好不要使用像素作为单位，因为打印样式表要打印出来的会是实物，所以建议使用pt和cm。 3、隐藏掉不必要的内容。（@print div{display:none;}） 4、打印样式表中最好少用浮动属性，因为它们会消失。 在书写高效 CSS 时会有哪些问题需要考虑?1）reset。参照下题“描述下 “reset” CSS 文件的作用和使用它的好处”的答案。 2）规范命名。尤其对于没有语义化的html标签，例如div，所赋予的class值要特别注意。 3）抽取可重用的部件，注意层叠样式表的“优先级”。 css预处理器主流的有less,sass,stylus http://lesscss.org/features/#features-overview-feature 优点：CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。 缺点：学习成本高，可维护性差；加上模块化组件的兴起，组件化思想流行，可维护性强 非标准字体http://blog.csdn.net/xujie_0311/article/details/42368371 1、用图片代替 2、web fonts在线字库，如Google Webfonts，Typekit等等；http://www.chinaz.com/free/2012/0815/269267.shtml； 3、@font-face，Webfonts 请解释浏览器是如何判断元素是否匹配某个 CSS 选择器？http://blog.csdn.net/qq_21397815/article/details/72874932 从右向左判断 请描述伪元素 (pseudo-elements) 及其用途。css3中用::两个冒号来表示伪元素::before,::after，以区分伪元素和伪类:hover,:active. 伪元素不属于html文档，所以js无法操作他； 伪元素作为主元素的一部分，因此点击事件的触发实际上是在主元素上触发 请解释你对盒模型的理解，以及如何在 CSS 中告诉浏览器使用不同的盒模型来渲染你的布局。W3C盒子模型——属性高（height）和属性宽（width）这两个值不包含 填充（padding）和边框（border） IE盒子模型——属性高（height）和属性宽（width）这两个值包含 填充（padding）和边框（border） http://blog.csdn.net/xujie_0311/article/details/42372871 * { box-sizing: border-box; }的作用与好处IE对盒模型的解析出现一些问题，跟其它浏览器不同，将 border 与 padding 都包含在 width 之内。而另外一些浏览器则与它相反，是不包括border和padding的。对于IE浏览器，当我们设置 box-sizing: content-box; 时，浏览器对盒模型的解释遵从我们之前认识到的 W3C 标准，当它定义width和height时，它的宽度不包括border和padding；对于非IE浏览器，当我们设置box-sizing: border-box; 时，浏览器对盒模型的解释与 IE6之前的版本相同，当它定义width和height时，border和padding则是被包含在宽高之内的。内容的宽和高可以通过定义的“width”和 “height”减去相应方向的“padding”和“border”的宽度得到。内容的宽和高必须保证不能为负，必要时将自动增大该元素border box的尺寸以使其内容的宽或高最小为0。 使用 * { box-sizing: border-box; }能够统一IE和非IE浏览器之间的差异。 https://www.jianshu.com/p/2353c364318b block,inline-block,inline的区别https://www.cnblogs.com/Ry-yuan/p/6848197.html inline:使元素变成行内元素，拥有行内元素的特性，即可以与其他行内元素共享一行，不会独占一行. 不能更改元素的height，width的值，大小由内容撑开. 可以使用padding，margin的left和right产生边距效果，但是top和bottom就不行. block:使元素变成块级元素，独占一行，在不设置自己的宽度的情况下，块级元素会默认填满父级元素的宽度. 能够改变元素的height，width的值. 可以设置padding，margin的各个属性值，top，left，bottom，right都能够产生边距效果. inline-block:结合了inline与block的一些特点，结合了上述inline的第1个特点和block的第2,3个特点. 用通俗的话讲，就是不独占一行的块级元素。 请解释 relative、fixed、absolute 和 static 元素的区别http://blog.163.com/love_heartbreaking/blog/static/124561901201211334714800/ 1、static：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 2、relative：生成相对定位的元素，通过top,bottom,left,right的设置相对于其正常位置进行定位。可通过z-index进行层次分级。 3、absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。 4、fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。 relative,absolute的区别 1、relative。定位为relative的元素脱离正常的文本流中，但其在文本流中的位置依然存在。absolute。定位为absolute的层脱离正常文本流，但与relative的区别是其在正常流中的位置不在存在。 2、relative定位的层总是相对于其最近的父元素，无论其父元素是何种定位方式。 abosulte红色背景层依然定义top:20px；left:20px；但其相对的元素变为定位方式为absolute或relative的黄色背景层。因此，对于absolute定位的层总是相对于其最近的定义为absolute或relative的父层，而这个父层并不一定是其直接父层。如果其父层中都未定义absolute或relative，则其将相对body进行定位 css样式的优先级https://www.cnblogs.com/qjqcs/p/5024016.html?utm_source=tuicool&amp;utm_medium=referral CSS三种位置写法的优先级是：行内样式＞内页样式＞外部样式 从样式选择器看权重优先级：important &gt; 内嵌样式 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 继承 &gt; 通配符。 important的权重为1,0,0,0 ID的权重为0,1,0,0 类的权重为0,0,1,0 标签的权重为0,0,0,1 伪类的权重为0,0,1,0 属性的权重为0,0,1,0 伪对象的权重为0,0,0,1 通配符的权重为0,0,0,0 css框架boostrap 不兼容ie6； jquery mobile:http://blog.jobbole.com/30216/ （不能访问摄像头，相册） 请问你有尝试过 CSS Flexbox 或者 Grid 标准规格吗？flexbox 阮一峰 响应式设计 自适应设计http://www.woshipm.com/pd/153425.html 响应式设计主要运用媒体查询和viewport来解决问题缺点：需要考虑多种情况，制定多种专门的样式 自适应设计 兼容 retina 屏幕http://www.ui.cn/detail/24556.html 当一个图像在标准设备下全屏显示时，一位图像素对应的就是一设备像素，导致一个完全保真的显示，因为一个位置像素不能进一步分裂。而当在Retina屏幕下时，他要放大四倍来保持相同的物理像素的大小，这样就会丢失很多细节，造成失真的情形。 在普通屏幕下，1个css像素 对应 1个物理像素(1:1)。在retina 屏幕下，1个css像素对应 4个物理像素(1:4)。 直接加载两倍大的图片，但是在一般屏幕下图片经过压缩，加载时间长。可以使用retina.js 准备两张尺寸的照片 媒体查询 translate 与 position二者都可以实现元素的位移，且效果一样；差别在于，transform 可以简单地作用于 position:absolute 的元素上面，而 position:relative; 还得加额外的 html 从动画角度来说 使用 transform 或 position 实现动画效果时是有很大差别。 使用 transform 时，可以让 GPU 参与运算，动画的 FPS 更高。 使用 position 时，最小的动画变化的单位是 1px，而使用 transform 参与时，可以做到更小（动画效果更加平滑） 总结 position 是为页面布局而生的。 transform 是为动画而生的。 https://segmentfault.com/a/1190000002436755 水平居中 行内元素 父元素：text-align:center 块状元素 必须设置width, 然后设置margin:0 auto; 不确定高度的块状元素 父元素：text-align:center 子元素:display:inline/inline-block 设置子元素：display:table; margin:0 auto; transform:tanslate(-50%,-50%); display:flex; justify-content:center 垂直居中 display:flex;algin-item:center; translate(-50%,-50%) 设置父元素：position:relative; 设置子元素：position:absolute; margin-top:(父元素height-子元素height)/2; 幻灯效果页面主要运用了animation动画效果；不听改变图片的透明度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.cb-slideshow&#123; width:400px; height:400px; margin:0 auto; z-index:0; &#125; .cb-slideshow li&#123; position:absolute; width:400px; height:400px; background-size:cover; background-repeat: none; opacity:0; z-index:0; -webkit-animation: loops 36s linear infinite 0s; &#125; .cb-slideshow li:nth-child(1)&#123; background-image: url(images/m10.jpg); &#125; .cb-slideshow li:nth-child(2)&#123; background-image: url(images/m11.jpg); -webkit-animation-delay: 6s; &#125; .cb-slideshow li:nth-child(3)&#123; background-image: url(images/m12.jpg); -webkit-animation-delay: 12s; &#125; .cb-slideshow li:nth-child(4)&#123; background-image: url(images/m15.jpg); -webkit-animation-delay: 18s; &#125; .cb-slideshow li:nth-child(5)&#123; background-image: url(images/m16.jpg); -webkit-animation-delay: 24s; &#125; .cb-slideshow li:nth-child(6)&#123; background-image: url(images/m17.jpg); -webkit-animation-delay: 30s; &#125; @-webkit-keyframes "loops" &#123; 0% &#123; opacity: 0; &#125; 8% &#123; opacity:1; &#125; 17% &#123; opacity:1; &#125; 25% &#123; opacity:0.5; &#125; 100% &#123; opacity: 0; &#125; &#125; 12345678&lt;ul class="cb-slideshow"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 什么是无样式内容闪烁?如何避免?https://www.jianshu.com/p/db82a546267a 先说说网页的渲染机制： 浏览器会解析这么三个东西：一个是html/svg/xhtml,解析他们会产生dom树；二是css文件，构建css rule tree(产生CSSOM：css object model);三是js脚本，通过dom api和cssom api来操作dom树和cssom 解析完成后，通过DOM tree和css rule tree构建渲染树rendering treeRendering Tree并不等同于DOM Tree，因为像header和display:none相关的东西就没有必要放在Rendering 渲染树中了CSS Rule Tree主要是为了将CSS Rule添加到Rendering Tree中的每一个element中，也就是DOM节点，然后计算每个DOM节点的位置，这个过程叫做layout，最后将页面绘制出来。 白屏和无样式内容闪烁（FOUC） 白屏和FOUC（无样式内容闪烁）的产生主要与浏览器的渲染机制有关，有的浏览器是等待html和css全部加载完成后再进行渲染（白屏问题），有的浏览器是先显示已加载的html内容，等到css加载完成后重新对内容添加样式（FOUC问题） 白屏的产生白屏的产生有三种情况：将css文件放在html文档的最后、使用@import引入css（因为通过@import引入的css文件会被最后加载，因此也会导致白屏）或者将js文件放在头部，而未使用defer或async延迟或异步加载js文件，导致js阻塞html和css的加载 FOUC的产生主要是由于浏览器先显示已加载的html内容，等到css加载完成后重新对内容添加样式导致的，主要代表有Firefox 如何避免 将css文件引用写在head标签里，不要@import css文件 将js文件引用写在前。 加载异步：defer和asnyc是脚本异步加载的两种方式。 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但 script.js 的执行要在所有元素解析完成之后DOMContentLoaded 事件触发之前完成。async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class与继承]]></title>
    <url>%2F2017%2F12%2F23%2FClass%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[简介ES5的继承，实质上是先创造子类的实例对象this,然后再将父类的方法添加到this上面。 123456function superType()&#123; this.colors = ['red','blue','black']&#125;function subType()&#123; superType.call(this);&#125; ES6的继承机制是：实例先创造父类的实例对象this(所以调用super方法),然后再用子类的构造函数修改this 1234567class colorPoint extends Point&#123; constructor(x,y,color)&#123; super(x,y)//调用父类构造函数中的（x,y） //super表示父类的构造函数，用来新建父类的this对象 this.color = color; &#125;&#125; 有两点需要注意的地方： 如果子类没有定义constructor方法，这个方法会被默认添加，即任何一个子类都有constructor方法; 子类构造函数中，只有调用super之后，才能使用this关键字，否则会报错；ES6要求，子类必须调用一次super函数 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 &#125;&#125; supersuper既可以当对象使用，也可以当函数使用 super用作函数是调用，代表父类的构造函数。 ES6要求，子类的构造函数中必须执行一次super函数。 1234567891011class A&#123;&#125;class B extends A&#123; constructor()&#123; super(); //super虽然指向的是父类的构造函数，但是返回的是子类B的实例 //即super内部的this指向是B //A.prototype.constructor.call(this) &#125;&#125;new A() //Anew B() //B super作为对象时，指向父类的原型对象 1234567891011calss A&#123; p()&#123; return 2 &#125;&#125;class Bextends A&#123; constructor()&#123; super(); console.log(super.p()) //2 //指向`A.prototype` 即`A.prototype.p()` &#125;&#125;let b = new B(); 类的prototype属性和 proto属性大多数浏览器的 ES5 实现之中，每一个对象都有 __ proto__属性，指向对应的构造函数的prototype属性,而在ES6中： 子类的_ proto _属性，表示构造函数的继承，总是指向父类. 123class AA&#123;&#125;class BB extends AA&#123;&#125;BB.__proto__ //class AA&#123;&#125; 子类prototype属性的_proto_属性，表示方法的继承，总是指向父类的prototype属性 12BB.prototype //AA &#123;constructor: ƒ&#125;BB.prototype.__proto__ //&#123;constructor: ƒ&#125; 实例的 proto属性子类实例的__ proto__属性的__ proto__属性，指向父类实例的__ proto__属性。也就是说，子类的原型的原型，是父类的原型。 1234var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, 'red');p2.__proto__.__proto__ === p1.__proto__ // true 因此通过子类实例的_ proto_._ proto_属性，可以修改父类实例的行为。 12345p2.__proto__.__proto__.printName = function () &#123; console.log('Ha');&#125;;p1.printName() // "Ha" 原生构造函数的继承extends关键字不仅可以用来继承类，还可以用来继承原生构造函数。ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象的this，然后再用子类构造函数修饰this，使得父类所有的行为都可以被继承。123456789101112class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;var arr = new MyArray();arr[0] = 12;arr.length // 1arr.length = 0;arr[0] // undefined]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之Generator和async函数]]></title>
    <url>%2F2017%2F12%2F21%2FGenerator%E5%92%8Casync%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Generator函数有多种理解：首先它可以理解成是一个状态机，封装了许多的内部状态； 其次，它也是一个遍历器对象的生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。 Generator函数是一个普通函数，但有两个特质： （1）function关键字与函数名之间有一个*号 （2）函数体内使用yield表达式，定义不同的内部状态 Generator简介12345678910111213function* Hello() &#123; yield 100 yield (function () &#123;return 200&#125;)() return 300&#125;var h = Hello()console.log(typeof h) // objectconsole.log(h.next()) // &#123; value: 100, done: false &#125;console.log(h.next()) // &#123; value: 200, done: false &#125;console.log(h.next()) // &#123; value: 300, done: true &#125;console.log(h.next()) // &#123; value: undefined, done: true &#125; 执行var h = hello()生成一个Generator对象，不是普通的函数 执行hello()之后，hello内部的代码不会立即执行，而是处于一个暂停的状态 执行第一个h.next()时，会激活刚才的暂停状态，开始执行Hello内部的语句，但是，直到遇到yield语句。一旦遇到yield语句时，它就会将yield后面的表达式执行，并返回执行的结果，然后又立即进入暂停状态 执行第三个h.next()时，程序会打破暂停状态，继续往下执行，但是遇到的不是yield而是return。这就预示着，即将执行结束了。因此最后返回的是{ value: 300, done: true }，done: true表示执行结束，无法再继续往下执行了 Genarator基本操作遍历器对象Generator生成了一个遍历器对象，即Interator接口 1234567function* Hello() &#123; yield 100 yield (function () &#123;return 200&#125;)() return 300 &#125;const h = Hello()console.log(h[Symbol.iterator]) // [Function: [Symbol.iterator]] 执行hello()可以得到一个遍历器对象，可以使用next()或for...of进行操作 123456789console.log(h.next()) // &#123; value: 100, done: false &#125;console.log(h.next()) // &#123; value: 200, done: false &#125;console.log(h.next()) // &#123; value: 300, done: false &#125;console.log(h.next()) // &#123; value: undefined, done: true &#125;let ifor (i of h) &#123; console.log(i)&#125; 异步操作协程“协程”（coroutine），意思是多个线程互相协作，完成异步任务。一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。 协程A开始执行 协程A执行到一半，进入暂停，执行权转移到协程B 协程B交换执行权 协程A回复执行 123function* asyncJob()&#123; var f = yield readFile(fileA);&#125; asyncJob就是一个协程，yield命令表示执行到此处，执行权交给其他协程。协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。 thunk函数123456789101112// 正常版本的readFile（多参数版本）fs.readFile(fileName, callback);//Thunk版本var Thunk = function(filename)&#123; return function(callback)&#123; return fs.readFile(filename,callback) &#125;&#125;;var readFileThunk = Thunk(filename);readFileThunk(callback); 上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。 Gnerator中使用Thunk函数1234567const readFileThunk = thunkify(fs.readFile)const gen = function* () &#123; const r1 = yield readFileThunk('data1.json') console.log(r1) const r2 = yield readFileThunk('data2.json') console.log(r2)&#125; 需要注意的是这里调用函数的next()方法返回的是以回调函数为参数的Thunck函数，但这些仍然是一个手动执行流程。 Generator本质Generator能让一段程序执行到指定的位置先暂停，然后再启动，再暂停，再启动。 而这个 暂停 就很容易让它和异步操作产生联系，因为我们在处理异步操作时，即需要一种“开始读取文件，然后暂停一下，等着文件读取完了，再干嘛干嘛…”这样的需求。因此将Generator和异步操作联系在一起，并且产生一些比较简明的解决方案，这是顺其自然的事儿，大家要想明白这个道理。 不过，JS 还是 JS，单线程还是单线程，异步还是异步，callback还是callback。这一切都不会因为有一个Generator而有任何变化。 async-awaitawait后面跟的不再是一个thunk函数，而是一个promise对象。 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123; console.log(result);&#125;); async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之Promise]]></title>
    <url>%2F2017%2F12%2F08%2Fpromise%20ES6%2F</url>
    <content type="text"><![CDATA[Promise介绍promise是异步编程的一种解决方案，而传统的方案指的是回调函数或事件。 promise的本质上还是回调函数，通过注册promise对象执行成功与失败时的相应的回调函数。 但与回调函数方式有什么不同呢？在使用promise进行进一步处理时，唏嘘按照接口规定的方式编写处理代码。除promise对象规定的方法以外的方法是不可以使用的。而传统的异步请求是可以自己自由的定义回调函数的参数。 一方面增加了代码的可读性与理解性；一方面也是可以将复杂的异步处理进行模块化。 promise就像一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果，通过状态的改变来执行下一步的操作。 promise三种状态 pending–进行中（异步操作的初始状态） fulfilled–已成功 rejected–已失败 只有异步操作的结果才能决定当前是哪一种状态，任何其他操作都无法改变这个状态。 promise对象是一个构造函数，用来生成promise实例。promise构造函数接受一个函数作为参数，该函数有resolve和reject两个参数。resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 12345678const promise = new Promise(function(resolve,reject)&#123; ...some code&#125;);promise.then(function(value)&#123; //success&#125;,function(error)&#123; //fail&#125;) 基本用法12345678910function asynFunction()&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function () &#123; resolve('Async Hello world'); &#125;, 16); &#125;);&#125;asyncFunction().then((value) =&gt; console.log(value)) // =&gt; 'Async Hello world'.catch((error) =&gt; console.log(error)); 上述代码中，asynFunction()返回一个promise对象，且为该对象设置了.then调用时的回调函数。该promise对象会在setTimeout之后的16ms时被resolve, 这时 then 的回调函数会被调用，并输出 Async Hello world 。 一些point1. Promise在新建后就会立即执行。123456789101112let promise = new Promise(function(resolve,reject)&#123; console.log('promise'); resolve();&#125;) promise.then(function()&#123; console.log('resolved'); &#125;) console.log('hi'); //promise //hi //resolved 由于promise在新建后会立即执行，所以首先输出的是promise，然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 2.Promise.prototype.catch()Promise.prototype.catch()用来处理promise实例发生错误时的回调函数，是.then(null,rejection)的别名。 12p.then((val) =&gt; console.log('success')).catch((err) =&gt; console.log('failed'));]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 6种声明变量的方法]]></title>
    <url>%2F2017%2F09%2F08%2FES6%206%E7%A7%8D%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[除了var，function以外，ES6新增了6种声明变量的方法。 let命令let声明的变量，只能在其命令所在的代码块内有效。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP首部字段]]></title>
    <url>%2F2017%2F09%2F08%2Fhttp%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[http协议的请求和响应报文必定包含http首部首部内容是客户端和服务器请求或响应时所提供的需要的信息。 请求报文与响应报文构成请求报文由方法，URI，http版本、首部字段组成。 响应报文由http版本，状态码，首部字段组成。 构成 请求报文 响应报文 报文首部 请求行、通用/请求/实体首部字段 请求行、通用/请求/实体首部字段 主体部分 报文主体 报文主体 首部字段首部字段在客户端与服务器通信中，起到传递重要信息的作用。首部字段是为了给浏览器 和服务器提供报文大小、认证信息、缓存等内容。 字段结构 首部字段名：字段值 4种字段类型 通用首部字段 请求/相应首部字段 实体首部 接下来我们详细讲一下每个字段的具体内容 http/1.1通用首部字段通用首部字段指的是请求报文和响应报文都会使用的首部。 1. Cache-Control通过指定Cache-Control的值，就能操作缓存的工作机制。指令可为多个，且用”，“来间隔 1Cache-Control: private, max-age = 0, no-cache 表示能否缓存的指令 public指令 表明可向任一用户提供响应的缓存 private指令 与public相对的，表明响应的缓存只向特定用户提供 no-cache指令 确定缓存的有效性，防止返回过期的缓存 客户端请求包含no-cache：表示客户端不会接受缓存服务器发来的缓存，处于中间的缓存服务器就会把请求发给源服务器。 服务器请求包含no-cache：缓存服务器不能对资源进行缓存。以后也不会对缓存服务器的资源进行确认，且禁止对任何资源进行缓存。 1Cache-Control:no-cache = Location 如果对字段名指定具体参数值，客户端接受到服务器返回的响应报文后，就不能使用缓存了。也就是说，无村塾的首部字段可以使用缓存。++且该参数只能在响应报文中指定。++ 控制可执行缓存的对象的指令 no-store指令 规定不能缓存请求或响应的任一部分 指定缓存期限和认证的指令 s-maxage 只适用于拱多位用户使用的公共缓存服务器 1Cache-Control:s-maxage = 604800（秒） max-age 客户端角度 如果在缓存期限内，即判定当前的缓存期限小于指定时间，则向客户端发送缓存的数据。1Cache-Control:s-maxage = 0（秒） 当值为0时，那么缓存服务器需要将请求发送给园服务器。 服务器角度 缓存服务器不再对缓存的期限进行确认。 min-fresh指令 超过期限就无法返回缓存，只返回指定时间内的缓存。 max-scale缓存过期也照常接收。 only-if-cached 客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。缓存服务器不重新加载响应，不确认缓存的有效性。 must-revalidate指令 代理服务器向源服务器确定缓存的有效性。 proxy-cache 所有缓存服务器在接受客户端带有该指令的情求返回响应之前，必须再次验证缓存的有效性。 no-transform 缓存不能改变实体主体的媒体类型。 2. Connection指令具有两个作用： 控制不再转发给代理的首部字段：可控制代理服务器不再转发部分字段 1Connection: 不再转发的首部字段名 管理持久连接 1Connection:close http/1.1默认状态下是持久连接的。 1Connection：Keep-Alive http/1.1之前的版本都是非持久连接的，所以可以指定字段值keep-alive. 3. Date表明创建报文的日期和时间 4. Pragma1Pragma:no-cache 所有的中间服务器的http版本不一定都是1.1，因此发送的请求会包含下面两个字段 12Cache-Control:no-cachePragma:no-cache 5. Trailer该字段会实现说明在斑纹主体后记录了哪些首部字段 123Trailer:Expries...报文主体...Expries:详细内容 6.Transfer-Encoding7. Upgrade用于检测http协议以及其他协议是否可使用更高的版本进行通信 12upgrade: TLS/1.0Connection: ugrade upgrade首部字段产生作用的对象仅限于客户端与邻接服务器，因此在指定upgrade字段时还得指定connection字段。 8.via追踪客户端和服务器之间请求或响应报文的传输路径。 9.Warning1Warning:[警告码][警告主机：端口号][警告内容][日期] http/1.1请求首部字段1.hosthost会告知服务器，请求的资源所处的互联网主机名和端口号 一个IP地址可对应多个域名：一台服务器（虚拟主机）只有一个IP，上面可以存放千万个网站，当这些网站请求到来时，服务器会根据host字段的值中的主机名来确定本次请求的资源在哪个服务器上。 IP地址相当于通信地址，都是由数字组成的，不利于记忆，因此为了方便记忆，定义了域名，所以人们都是访问baidu.com，而不是ip地址。 1host:www.baidu.com http/1.1响应首部字段1.varyvary可对缓存进行控制，源服务器向代理服务器传达关于缓存使用方法的命令。 当客户当与代理服务器都带有相同值的vary指令时，那么就直接从代理服务器发送缓存给客户端，如果不相同，则向源服务器发送请求。 从代理服务器收到源服务器返回的包含vary的响应后，如果再要进行缓存，则仅对请求中的vary指令值相同时返回缓存。]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2017%2F09%2F08%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[对于闭包的理解就是用来读取函数内部变量的函数。在js中只有子函数才能读取去不函数内的变量，因此，闭包就是定义在一个函数内部的函数。 123456789 function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型]]></title>
    <url>%2F2017%2F09%2F08%2F%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[探讨原型之前，我们先探讨下对象和函数的关系： 对象与函数我们一直都知道，函数是对象的一种，通过instanceof函数可以判断；再去看数据，我们也知道数组也是对象的一种，他就是数组的一个子集；但是我们又可以说所有对象都是通过函数创建的；所以，函数和对象的关系有种鸡生蛋蛋生鸡的关系 123var obj = new object();obj.a = 10;obj.b = 5; 原型与原型链原型prototype我们得先弄清原型、实例、构造函数三者之间的关系 首先 每个函数都具有prototype这个属性，函数的prototype属性指向函数的原型 其次，每个原型对象都具有一个constructor指针指向构造函数本身； 再者，每个对象都具有一个隐式原型 proto指向他的原型，所以，所有实例也指向原型对象 每个对象都有一个proto属性，指向创建该对象的函数的prototype 12person.prototype.constructor = person;new person()._proto_ = person.prototype; 由于所有函数也是对象，所以函数也会有自己的原型，他的prototype属性会指向她的原型，而所有的函数也具有自己的函数原型，所有的函数原型也是对象，都是被object创建，所以他的proto属性指向object.prototype.但是Object.prototype确实一个特例——它的proto指向的是null ###原型链的两个问题 1.众所周知的是，原型对象的所有属性会被所有是咧共享，所以一部分实例属性应该定义在构造函数中，而共享的原型属性应写在原型对象中。原型对象也具有这样的问题，原型会成为另一个对象的实例，所以实例属性就变成了原型属性。 2.在创建子类型的实例时，不能向超类型的构造函数中传递参数 问题解决：组合继承 原型链和借用构造函数的组合，使用原型链实现对原型属性的继承，使用构造函数实现对实例属性的继承，call()方法实现继承，并传入参数。看下面这个例子： 12345678910111213141516171819202122232425262728function sup(name)&#123; this.name = name; this.color = ["red","blue"] //构造函数里定义了name,color属性 &#125;; sup.prototype.sayname = function()&#123; alert(this.name); &#125;; function sub(name,age)&#123; sup.call(this,name);//继承了sup的构造函数属性 第二次调用 this.age = age; &#125;; sub.prototype = new sup();//sub原型指向sup的实例，具有了name,color属性 第一次调用sup sub.prototype.constructor = sub; sub.prototype.sayage = function()&#123; alert(this.age); &#125;; var instance1 = new sub("Nick",29); instance1.color.push("black") alert(instance1.color);//"red","blue","black" instance1.sayname();//"Nick" instance1.sayage();//29 var instance2 = new sub("John",31); alert(instance1.color);//"red","blue" instance1.sayname();//"John" instance1.sayage();//31 由于sub的原型指向了sup的实例，所以存在sup构造函数里的name,color属性也继承到了sub的原型里，因此，运行函数是，可以在sub的原型对象里找到name,color属性。 但由于运用了call()函数，所以sub的构造函数的对象里也具有color,name的实例属性，所以，当构造函数sub()调用时，首先搜索的是构造函数里的实例属性。所以，每个实例，instance1,instance2都有自己的实例属性的副本。 组合式继承融合了原型链和构造函数的优点，成为js中最常用的继承模式。 上述例子由于两次调用sup函数而使得在instance实例和sub原型中具有两个相同的同名属性，为了解决这个问题便引出了寄生组合式继承，详见书173页。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的几种布局]]></title>
    <url>%2F2017%2F09%2F08%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[两列布局左列定宽，右列自适应12.left&#123;float：left; width:100px;&#125;.right&#123;margin-left:100px&#125; IE6会有3像素的bug 三列布局这三种布局基本都是当今网页布局比较常用的布局方式：左中右三栏布局，左右两栏宽度固定（要是不想固定将宽度改成百分比），中间栏宽度自适应。 绝度定位法左右两栏采用绝对定位，固定于页面两侧；中间栏用左右margin值撑开距离。 12345&lt;body&gt; &lt;div id="left" style="position:absolute; width:200px; left:0;"&gt;&lt;/div&gt; &lt;div id="main" style="margin:0 210px"&gt;&lt;/div&gt; &lt;div id="right" style="position:absolute; width:200px;"&gt;&lt;/div&gt;&lt;/body&gt; margin负值法这种方法是在实际的网站中应用的最多的，中间主体使用双层标签，内层div为真正的主体内容，含有左右210像素的margin值。左右栏采用maigin负值定位：margin-left:-100% 1234567&lt;body&gt; &lt;div style="float:left margin:0;"&gt; &lt;div width:100%,float:left&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id="left" style="width:200px; margin-left:-100%;float:left"&gt;&lt;/div&gt; &lt;div id="right" style=" width:200px; margin-left:-200px;float:left"&gt;&lt;/div&gt;&lt;/body&gt; 自身浮动法左栏左浮动，右栏右浮动，中间部分自适应12345&lt;body&gt; &lt;div id="left" style="width:200px; float:left"&gt;&lt;/div&gt; &lt;div id="right" style="width:200px; float:right"&gt;&lt;/div&gt; &lt;div style="margin:0 210px;"&gt;&lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js单线程相关理解]]></title>
    <url>%2F2017%2F09%2F08%2Fjs%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一直不太理解单线程是什么意思，刚看了一些博客的讲解好像懂了一些。今天就来谈谈这个问题。 js是单线程的，这是毋庸置疑的，那么js是怎么实现异步请求的呢？js本身是不可能异步的，但js的宿主环境，如浏览器、node都是多线程的，宿主环境通过某种方式使得js具备了异步的属性。 js为什么是单线程的？js的单线程机制，与它用途有关。作为浏览器脚本语言，js的主要用途是与用户互动，以及操作DOM。这就决定了它的单线程。 如果js同时有两个线程，一个线程在某个节点上添加了内容，另一个线程删除了这个节点，这就导致了混乱，所以js从一诞生就是单线程的。 浏览器的多线程浏览器是多线程的，浏览器只给js分配了一个线程来执行任务（函数），但由于js是单线程的，因此一次只能执行一个任务，这些任务形成一个任务队列（callback queue）等候执行。这意味着完成队列的所有任务会非常的耗时，且效率低。所以浏览器为这些耗时的任务开辟了另外的线程，并由这些线程实现异步。 下面是浏览器的主要线程： 界面渲染线程 浏览器事件触发线程 http请求线程 js引擎线程 任务队列callback queue单线程意味着所有任务都得排队，前一个没有结束，后一个任务就得一直等着。只有前一个任务执行完了才会执行下一个任务。但是在开发的后期，人们逐渐意识到不必等前一个任务结束再折行下一个任务（如IO设备，ajax操作）。可以把处于等待中的任务挂起，先运行排在后面的任务。等IO设备返回了结果再回头把挂起的任务继续执行下去。 于是所有的任务分为两种，同步任务和异步任务。同步指的是在主线程上排队执行的任务，只有前一个任务执行完毕，才会执行后一个任务； 异步任务指的是，不进入主线程，而是进而任务队列的任务，只有任务队列“通知”主线程异步任务可以执行了，就会执行任务队列的任务。 异步执行的运行机制如下:(同步执行也是如此，可视为没有异步任务的异步执行) 所有的同步任务都在主线程上执行，形成一个执行栈 主线程外，还存在一个“任务队列”，只有异步运行有了结果，就会在“任务队列”中放置一个事件。（这里的事件在我的理解是通过回调函数进入任务队列） 执行栈中的所有同步任务执行完毕，系统会处理“任务队列”里的任务。并进入执行栈，开始执行 主线程不断重复上面的第3步。 上图很好的诠释了异步的机制，也展现出异步的优点。 回调函数在讲任务队列之前我得先讲一下回调函数，因为看到这里时对回调函数产生了模糊。特地仔细研究了下回调函数。之前对于回调函数接触是在ajax里面，ajax请求返回后才执行回调函数里面的内容。 “任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 而这些事件是怎么进入“任务队列”的呢？答案是回调函数。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 事件循环 Event Loop主线程从“任务队列”中读取事件，这个循环的过程又被称为事件循环Event loop。 主线程在运行的时候，产生堆（heap）和栈（stack），函数的执行就是通过进栈和出栈实现的，栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。 定时器“任务队列”还可以放置定时事件。setTimeout()函数接收两个参数，一个是回调函数，一个是任务执行前需等待的时间。 12345console.log(1);setTimeout(function()&#123; consoloe.log(2);&#125;,1000);console.log(3); //1,3,2 setTimeout()将第二行推迟到1000毫秒之后执行。 12setTimeout(function()&#123;console.log(1);&#125;,0);console.log(2); //2,1 如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。 总之，setTimeout(fn,0)指的是某个任务在主线程最早可得的空闲时间执行，也就是尽可能早的执行。他在任务队列的尾部添加了一个时间，因此要等到所有同步任务和“任务队列”的任务处理完，再会执行。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
