<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[html面经积累]]></title>
    <url>%2F2018%2F02%2F02%2Fhtml%E9%9D%A2%E7%BB%8F%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[doctype（文档类型）的作用文档头部加上&lt;!DOCTYPE html&gt;使得浏览器按照w3c标准来解析渲染页面，避免ie等版本下的怪异模式 浏览器标准模式 (standards mode) 、几乎标准模式（almost standards mode）和怪异模式 (quirks mode) 之间的区别是什么？https://www.jianshu.com/p/dcab7cde8c04 http://www.frontopen.com/1385.html 在“标准模式”(Standards Mode) 页面按照 HTML 与 CSS 的定义渲染，而在“怪异模式”(Quirks Mode)就是浏览器为了兼容很早之前针对旧版本浏览器设计、并未严格遵循 W3C 标准的网页而产生的一种页面渲染模式。浏览器基于页面中文件类型描述的存在以决定采用哪种渲染模式；如果存在一个完整的DOCTYPE则浏览器将会采用标准模式，而如果它缺失则浏览器将会采用怪异模式。 盒模型的处理差异 行内元素的垂直对齐 元素溢出等问题 HTML 和 XHTML 有什么区别？ 如果页面使用 ‘application/xhtml+xml’ 会有什么问题吗？ 网页需要支持多语言多语言网站实现计划 ： 1、静态：就是为每种语言分辨准备一套页面文件，要么通过文件后缀名来区分不同语言，要么通过子目录来区分不同语言。例如对于首页文件index_en.htm供给英语界面，index_gb.htm供给简体中文界面，index_big.htm供给繁体中文界面，或者是en/index.htm供给英语界面，gb/index.htm供给简体中文界面，big/index.htm供给繁体中文界面，一旦用户选择了需要的语言后，主动跳转到相应的页面，首页以下其他链接也是按照同样方法处理。从保护的角度来看，通过子目录比通过文件后缀名来区分不同语言版本显得要简略明了。 2，动态：站点内所有页面文件都是动态页面文件（PHP，ASP等）而不是静态页面文件，在需要输出语言文字的处所同一采用语言变量来表现，这些语言变量可以根据用户选择不同的语言赋予不同的值，从而能够实现在不同的语言环境下输出不同的文字。例如：语言变量ln_name，当用户选择的语言是英语时赋值为“Name”，当用户选择的语言是简体中文时赋值为“姓名”，这样就可以适应不同语言时的输出。 采用静态方法的长处是页面直接输出到客户端，不需要在服务器上运行，占用服务器的资源比拟少，系统能够支撑的并发连接数较多，毛病是要为每种语言制作一套页面文件，很多内容即使是和语言无关的也要分不同语言来存储，因此占用的存储空间较多。 采用动态方法和静态方法的优毛病正好相反，它的长处是动态页面文件只有一套，不同语言的文字应用语言变量来存储，和语言无关的内容只存储一份，占用的存储空间较少，并且扩大新语言比拟轻易，毛病需要在服务器上运行，然后把成果输进到客户端，占用服务器的资源比拟多，系统能够支撑的并发连接数较少。 使用 data- 属性的好处是什么https://www.cnblogs.com/dolphinX/p/3348458.html data- 实际上上就是data-前缀加上自定义的属性名，使用这样的结构可以进行数据存放。使用data-可以解决自定义属性混乱无管理的现状。 如果把 HTML5 看作做一个开放平台，那它的构建模块有哪些？ 请描述 cookies、sessionStorage 和 localStorage 的区别。https://www.cnblogs.com/jacobb/p/6824838.html 什么是渐进式渲染]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js面经积累]]></title>
    <url>%2F2018%2F01%2F23%2Fjs%E9%9D%A2%E7%BB%8F%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[一些判断 typeof操作符可以判断number,boolean,string,function,undefined; 判断array需要用array.isArray(arr); 判断null需要用myVar === null; 判断某个全局变量是否存在使用typeof window.myVar === &#39;undefined&#39;; 函数内部判断某个变量是否存在用typeof myVar === &#39;undefined&#39; for…in 和 for…of 的区别for...in由于历史遗留问题，它的遍历实际上是对象属性的遍历，一个array数组实际上也是一个对象，对象属性即是数据的索引 1234var arr = [1,2,3];for(var x in arr)&#123; console.log(x); //0,1,2&#125; for...of循环则完全修复了这些问题，它只循环集合本身的元素： 12345var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x of a) &#123; console.log(x); // 'A', 'B', 'C'&#125; rest参数es6引入rest参数，为了获得额外的参数 12345678910function foo(a, b, ...rest) &#123; console.log('a = ' + a); console.log('b = ' + b); console.log(rest);&#125;foo(1, 2, 3, 4, 5);// a = 1 b = 2 Array [ 3, 4, 5 ]foo(1);//a = 1 b = undefined Array [] 变量提升函数定义有个特点，他会先扫描整个函数体的语句，把所有声明的变量提升到函数顶部 123456function foo() &#123; var x = 'Hello, ' + y; console.log(x); var y = 'Bob';&#125;foo(); //hello,unddefined 上函数体内的第一句并不会报错，因为y变量在后面已经声明了，但函数尚未运行到该句，所以y此时是undefined 由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量 名字空间全局变量会绑定到window上，不同的js文件如果使用了相同的全局变量，或者定义了相同的顶层函数，都会造成命名冲突。减少这种冲突的方法就是把自己的所有变量和函数全部绑定到一个全局变量中。 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return 'foo';&#125;; let constlet用来声明变量，与var类似。但let声明的变量只在所在的代码块中有效。 为了纠正var变量提升的现象，let声明的变量不存在变量提升，所有的变量必须在声明后使用。如果在变量声明之前调用，则会报错，语法上称为‘暂时性死区’。 const声明一个只读的常量。一旦声明，常量的值就不能改变。并且只在块级作用域中有效。也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 解构赋值从数组和对象中提取值，对变量进行赋值，这被称为解构,属于模式匹配。并允许指定默认值 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 对象的解构赋值与数组不同，对象的解构必须属性名一致。 123456let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let &#123; foo: baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // "aaa"foo // error: foo is not defined 字符串的解构赋值是把字符串转化成了类似于数组的对象 12const [a,b,c,d,e] = 'hello';a; //'h' 数值和布尔值的解构赋值是先将数值和布尔值转化成对象 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true apply和call两者都是用来引入另一个对象的方法，或是用另一个对象替换当前的对象。 12B.apply(A,[argument1, argument2]);//A对象调用B对象的方法，this指向AB.apply(A,argument1, argument2);//A对象调用B对象的方法，this指向A 唯一区别：传入参数的表示形式不同 apply()把参数打包成Array再传入； call()把参数按顺序传入。 箭头函数的this箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数内部的this是词法作用域，由上下文确定。比较下面两个例子 1234567891011var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = function () &#123; return new Date().getFullYear() - this.birth; // this指向window或undefined,通过var that = this来修正this的指向。 &#125;; return fn(); &#125;&#125;; 箭头函数修复了this的指向问题，指向词法作用域。 123456789var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); &#125;&#125;;obj.getAge(); // 25 事件代理/委托https://zhuanlan.zhihu.com/p/26536815 通俗的讲，就是把一个元素的响应事件委托给另外一个元素，通过目标元的判断来确定事件函数的触发。 事件模型分为三个阶段： 事件捕获：事件从文档根节点触发，根据DOM树结构依次向目标节点流去，途中经过各个层次的节点，并在节点上触发捕获事件，直到到达目标节点（在事件魔炮的模型中，捕获阶段不会响应任何事件） 目标阶段：事件响应到触发事件的最底层元素上； 冒泡阶段：事件依次由最底层的目标节点向父元素冒泡，直到根节点。（事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层） 优点： 减少内存消耗 动态绑定事件 12345678910// 给父层元素绑定事件document.getElementById('list').addEventListener('click', function (e) &#123; // 兼容性处理 var event = e || window.event; var target = event.target || event.srcElement; // 判断是否匹配目标元素 if (target.nodeName.toLocaleLowerCase === 'li') &#123; console.log('the content is: ', target.innerHTML); &#125;&#125;); 请解释 JavaScript 中 this 是如何工作的http://snailsky.me/2014/08/31/javascript-%E4%B8%AD-this-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/ this就是指当前函数的运行环境。由于js支持运行环境的动态切换，所以this指向也是动态的；this指函数运行时所在的那个对象。 全局环境 this指向顶层对象window 构造函数 this指向实例对象 方法调用 当A对象的方法赋给了B对象，改方法就变成了普通函数，其this指向就从A对象变成了B对象，这就是this取决于运行时所在的对象的含义。付过将某个对象的方法赋给另外一个对象，会改变this指向 12345678var o1 = new Object();o1.m = 1;o1.f = function ()&#123; console.log(this.m);&#125;;o1.f() // 1var o2 = new Object();o2.m = 2;o2.f = o1.fo2.f() // 2 bind方法http://blog.jobbole.com/58032/ 地将函数体内的this绑定到某个对象，然后返回一个新函数（返回由指定的this值和初始化参数改造的原函数拷贝）。它的使用格式如下。 B.bind(A,arg1,arg2) //this指向A;如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象 123456789101112var o1 = new Object();o1.p = 123;o1.m = function ()&#123; console.log(this.p);&#125;;o1.m() // 123var o2 = new Object();o2.p = 456;o2.m = o1.m;o2.m() // 456o2.m = o1.m.bind(o1);o2.m() // 123 你怎么看 AMD vs. CommonJScommmenJS主要运用于服务器模块，node使用的就是commonJS规范，用于服务器端环境。commonJS规范属于同步加载模块，对于服务器端这并不是一个问题，因为所有的模块都存放在本地磁盘，所以加载时间并不是问题；而到了浏览器端，可能会造成较长的等待时间，造成页面‘假死’。 因此浏览器端的模块不能采用‘同步加载’，所以就有了AMD规范。 AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 require([module],callback) 123require(['msth'],function(math)&#123; math.add(2,3)&#125;) math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html IIFE立即执行函数表达式https://segmentfault.com/a/1190000003902899 12var foo = function&#123;...&#125;; //立即执行函数表达式function foo()&#123;...&#125;(); //报错 上面第二个例子会报错，是因为function关键字既可以当做语句，也可以当做表达式，当function出现在行头时，一律解释为语句和一般的函数定义。所以下面的是正确的： 123456789(function ()&#123;...&#125;()); //推荐使用这个(function ()&#123;...&#125;)(); //也可以使用这个// 由于括弧()和JS的&amp;&amp;，异或，逗号等操作符是在函数表达式和函数声明上消除歧义的var i = function () &#123; return 10; &#125; ();true &amp;&amp; function () &#123; /* code */ &#125; ();0, function () &#123; /* code */ &#125; ();!function () &#123; /* code */ &#125;(); 只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 null，undefined 或 undeclaredd的区别null是原始类型之一，表示对象值为空；使用typeof类型判断为object;与””,’’不等价。 undefind只定义未赋值 undeclared未定义变量就使用 12val === 'object' &amp;&amp; null; //判断nulltypeof(val) === 'undefined' //判断undefined 你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？ JavaScript 宿主对象 (host objects) 和原生对象 (native objects)、内置对象 ？ 宿主对象：“宿主”当然就是我们网页的运行环境，即“操作系统”和“浏览器”。所有非原生对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。包括BOM（浏览器对象），DOM对象。 原生对象：“独立于宿主环境的 ECMAScript 实现提供的对象”。即ECMA定义的类（引用类型） Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError、ActiveXObject(服务器方面)、Enumerator(集合遍历类)、RegExp（正则表达式） 内置对象：定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了。即 Global 和 Math 函数表达式与函数声明123function foo()&#123;&#125;; //函数声明 存在变量提升var foo = function ()&#123;&#125; ; //函数表达式 也会提升 但会先将变量赋值给undefined，定义本身不会提升 http://web.jobbole.com/87534/ 在什么时候你会使用 document.write()？http://www.cnblogs.com/zichi/p/5303541.html document.write() 接收一个字符串作为参数，将该字符串写入文档流中。 在浏览器通过网络下载一个HTML文件时，需要做2个基本的事情：解析HTML流、构建DOM树解析HTML流即将HTML字符流变为一个语法可识别的token集合，说白了就是语法解析，随后基于解析后的token再形成我们熟知的DOM树如果使用document.write写入一个元素（无论是否是script），会造成HTML流被修改，此时浏览器需要额外做解析的工作，才可以继续DOM树的构建 而如果使用创建元素并append的方式，则只有DOM树发生变动，不需要额外的解析工作 除此之外，document.write出来的脚本会立即下载即行（同步阻塞），这会阻塞后续DOM的构建，如果这个脚本因网络等原因下载比较慢，页面就会处于半但是如果在后面有其它脚本依赖于你写入的script，那么使用document.write是一个比较好的选择，直接创建元素会导致异步让后续有依赖的脚本执行出错再者， 当页面已经完成加载（DOMContentLoaded事件触发）时，HTML流会被关闭，此时无法使用document.write，如果强制使用会使得原来的页面消失，这个大部分人都明白最后， 低版本的IE浏览器（如IE6）下，document.write写入的脚本执行时机是错误的，其时机控制非常复杂，如果你对脚本的执行顺序有要求的话，这一兼容性问题会让你头疼，这里摘录我以前做出的总结 请指出浏览器特性检测，特性推断和浏览器 UA 字符串嗅探的区别http://blog.720ui.com/2015/js_practice_03_useragent/ 特性检测 并非所有的浏览器都支持相同的特性，这里的特性是指对于JavaScript开发人员而言可以在代码中访问和使用的特性。特性检测是指检测浏览器是否支持某个给定特性的过程，该方法是浏览器检测的首选方法。使用该方法时，需要做少许的维护工作，所有实现（或不实现）特定特性的浏览器都使用这种方法来检测代码的执行。 特性检测的模式很简单：首先检查特性是否存在，如果存在，就使用该特性。因此，使用一个if语句即可实现，如下所示： 123if(navigate.geolocation)&#123; //user geolocation&#125; UA（user Agent用户代理）检测 浏览器的嗅探主要基于Window对象的Navigator属性对浏览器的类型、名称、厂商以及运行环境等作出判断，满足不同生产环境的需求。 Ajax 的工作原理及优缺点https://www.cnblogs.com/mingmingruyuedlut/archive/2011/10/18/2216553.html Ajax的原理简单来说就是通过XMLhttpRequest对象来想服务器发送异步请求，从服务器获得数据，然后用js来操作DOM实现局部更新页面的效果。 XMLhttpRequest是Ajax的核心机制，是一种支持异步请求的技术。也就是js可以及时向服务器提出请求和处理响应，而不阻塞用户，达到无刷新效果。 XMLhttpRequest对象的属性有： onreadystatechange 每次状态改变所触发事件的事件处理程序。 responseText 从服务器进程返回数据的字符串形式。 responseXML 从服务器进程返回的DOM兼容的文档数据对象。 status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪） status Text 伴随状态码的字符串信息 readyState 对象状态值 0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法） 1 (初始化) 对象已建立，尚未调用send方法 2 (发送数据) send方法已调用，但是当前的状态及http头未知 3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误， 4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据 由于浏览器之间的差异： 123456789101112131415161718192021222324252627282930313233343536373839function CreateXmlHttp() &#123; //非IE浏览器创建XmlHttpRequest对象 if (window.XmlHttpRequest) &#123; xmlhttp = new XmlHttpRequest(); &#125; //IE浏览器创建XmlHttpRequest对象 if (window.ActiveXObject) &#123; try &#123; xmlhttp = new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e) &#123; try &#123; xmlhttp = new ActiveXObject("msxml2.XMLHTTP"); &#125; catch (ex) &#123; &#125; &#125; &#125; &#125; function Ustbwuyi() &#123; var data = document.getElementById("username").value; CreateXmlHttp(); if (!xmlhttp) &#123; alert("创建xmlhttp对象异常！"); return false; &#125; xmlhttp.open("POST", url, false); xmlhttp.onreadystatechange = function () &#123; if (xmlhttp.readyState == 4) &#123; document.getElementById("user1").innerHTML = "数据正在加载..."; if (xmlhttp.status == 200) &#123; document.write(xmlhttp.responseText); &#125; &#125; &#125; xmlhttp.send();&#125; 知道了XMLHttpRequest的工作流程，我们可以看出，XMLHttpRequest是完全用来向服务器发出一个请求的，它的作用也局限于此，但它的作用是整个ajax实现的关键，因为ajax无非是两个过程，发出请求和响应请求。并且它完全是一种客户端的技术。而XMLHttpRequest正是处理了服务器端和客户端通信的问题所以才会如此的重要。 优点 异步加载，良好的响应能力，不会打断用户的操作 减轻服务器的负担 无页面刷新，良好的用户体验 缺点 浏览器不兼容 - AJAX高度依赖JavaScript，而不同的浏览器对JavaScript支持性不同。这成了一个问题，尤其是当AJAX必须跨许多浏览器工作的时候。那些不支持JavaScript或者不支持JavaScript某些选项的浏览器将不能够正常使用ajax。由于ajax对JavaScript的依赖性，它不适用移动应用。你的web浏览器的后退键不能如期运行。 不安全性 - 网页可能很难调试，增加网页的代码量，你的网页更可能遇上严峻的安全威胁。 增加Web服务器的负载 - 如果你增加一个自动更新的功能，它每隔几秒向服务发起请求，那么就会增加服务器的负载。 jsonp的工作原理，以及为什么不是ajaxhttps://zhuanlan.zhihu.com/p/30664364https://segmentfault.com/a/1190000007665361 模板引擎handerlebars “attribute” 和 “property” 的区别是什么？http://www.cnblogs.com/elcarim5efil/p/4698980.html attribute保存了节点在html标签上从一开始设定的属性，他是一个Attr类型对象，拥有nodeType,nodeName等属性；打印attribute属性不会直接得到对象的值，而是获取一个包含属性名和值的字符串，如： 1console.log(in1.attibutes.sth); // 'sth="whatever"' DOM有其默认的基本属性，而这些属性就是所谓的“property”，无论如何，它们都会在初始化的时候再DOM对象上创建。如果在TAG对这些属性进行赋值，那么这些值就会作为初始值赋给DOM的同名property;下例中的value就是propoty属性，尽管没有赋值但是从一开始就存在。 123console.log(in2);//id:'in'//value:null propoty与attribute是单向绑定的，property能够从attribute中得到同步；attribute不会同步property上的值；更改property和attribute上的任意值，都会将更新反映到HTML页面中； 为什么说扩展内置对象是个不好的做法 请指出 document load 和 document DOMContentLoaded 两个事件的区别。当onload事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。 当DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。 DOM文档加载的步骤为 解析HTML结构。 加载外部脚本和样式表文件。 解析并执行脚本代码。 DOM树构建完成。//DOMContentLoaded 加载图片等外部文件。 页面加载完毕。//load 1234567document.addEventListener("DOMContentLoaded", function() &#123; // ...代码...&#125;, false);window.addEventListener("load", function() &#123; // ...代码...&#125;, false); == 和 === 有什么不同？==两遍值类型不同时，先做类型变换再比较； 如果类型相同，进行===比较 如果两个值类型不相同： 1 null == undefined; 0 == &#39;&#39;; 2 一个是字符串一个是数值，就把字符串转成数值再比较 1 = &quot;1&quot; 3 true转换成数值1， false转化成0 12345678910111213141516171819 '1' == true //字符串转成数值1，true转成数值1 1 == true //true转成数值1 ``` 4 对象转换成基础类型再比较（利用`toString`,`valueOf`） `===`严格等于，不做类型判断，直接比较，类型不同就不相同---#### JavaScript 的同源策略 (same-origin policy)http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html同源策略即三个相同：* 协议相同* 端口相同* 域名相同举例`http//www.example.com/dir/page.html`这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略） http://www.example.com/dir2/other.html：同源https://www.example.com/dir2/other.html：不同源（协议不同）http://v2.www.example.com/dir/other.html：不同源（域名不同）http://www.example.com:81/dir/other.html：不同源（端口不同）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253**目的**同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。&quot;同源政策&quot;是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。**限制范围**（1）Cookie、LocalStorage 和 IndexDB 无法读取。（2） DOM 无法获得。（3） AJAX 请求不能发送。**window.postMessage****ajax跨域问题*** 服务器代理* jsonp* websocket* cors---#### 浅拷贝、深拷贝https://segmentfault.com/a/1190000008637489https://github.com/wengjq/Blog/issues/3&gt; JavaScript存储对象都是存地址的，所以浅拷贝会导致 obj1 和obj2 指向同一块内存地址。改变了其中一方的内容，都是在原来的内存上做修改会导致拷贝对象和源对象都发生改变，而深拷贝是开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作互不影响。**变量类型**（1）基本类型：5中基本类型undefined，null,boolean,number,string，变量是直接按值存放在栈内存中的简单数据段，可以直接访问（2）引用类型：存放在堆内存中的对象，变量保存的是一个指针，当需要访问引用类型（如对象，数组）的值是，首先从栈中获得该对象的地址指针，再从堆内存中去的所需的数据。**浅拷贝**：拷贝原对象的引用```js// 对象var o1 = &#123;a: 1&#125;;var o2 = o1;console.log(o1 === o2); // =&gt;trueo2.a = 2; console.log(o1.a); // =&gt; 2 对象是引用类型，属于可变对象// 数组var o1 = [1,2,3];var o2 = o1;console.log(o1 === o2); // =&gt; trueo2.push(4);console.log(o1); // =&gt; [1,2,3,4] array,prototype.slice()和array.prototype.concat()都会返回数组或对象的浅拷贝 12345678910var 01 = ['adrk',&#123;age:22&#125;];var o2 = o1.slice();console.log(o1 === o2); //false 说明o2拷贝的是o1的一个实例o2[0] = 'lee';console.log(o1[0]); // =&gt; "darko" o1和o2内部包含的基本类型值，复制的是其实例，不会相互影响o2[1].age = 23;console.log(o1[1].age); // =&gt;23 o1和o2内部包含的引用类型值，复制的是其引用，会相互影响 深拷贝 拷贝实例，新的实例和之前的实例互不影响 还有一种实现深拷贝的方式是利用JSON对象中的parse和stringify，JOSN对象中的stringify可以把一个js对象序列化为一个JSON字符串，parse可以把JSON字符串反序列化为一个js对象，通过这两个方法，也可以实现对象的深复制。 严格模式好处及坏处http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html 请实现一个遍历至 100 的 for loop 循环，在能被 3 整除时输出 “fizz”，在能被 5 整除时输出 “buzz”，在能同时被 3 和 5 整除时输出 “fizzbuzz”。 为何通常会认为保留网站现有的全局作用域 (global scope) 不去改变它，是较好的选择？ 为何你会使用 load 之类的事件 (event)？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？http://horve.github.io/2015/10/17/domcontentloaded/ 页面加载完后执行，用户体验差； Jquery的$(&quot;document&quot;).ready(); DOMContentLoaded事件 123if ( document.addEventListener ) &#123; document.addEventListener( "DOMContentLoaded", completed, false );&#125; 请解释什么是单页应用 (single page app), 以及如何使其对搜索引擎友好 (SEO-friendly)。先解释下传统的MVC框架： 全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码 传统的网页应用中，浏览器充当展示层，路由处理、服务调用、页面跳转都由服务器端来处理。即MVC都放在放在服务器端，而V（视图）作为用户界面则通过网络发送到浏览器端，作为UI与用户交互。 有以下特点： 重服务端，由于 MVC 都存在于服务器上，因此这类应用在开发资源和开发的重心都偏向后端，往往是后端工程师来主导整个项目开发； 页面频繁刷新，由于浏览器端只是一个展现层，当页面功能有所变化的时，页面就刷新，这会导致资源的浪费，用户需要花费额外的时间等待页面刷新，用户体验不佳。 单页应用相对于传统页面，单页面应用MVC前置了浏览器前端： 控制器前置 单页应用将路由处理放在浏览器端，即在浏览器端直接响应浏览器地址的变化，分发到对应的路由，向用户呈现相应的界面。 以小块组件为功能原件 再路由变化时，不在刷新整个页面，而是只变更变化的部分，达到节约资源的目的 数据层前置，与 Ajax 组件一个明显的区别是，单页应用在浏览器端通常有一层实实在在的数据层，而服务端则退化成了完全的数据 API。浏览器端的数据层会封装服务端 API，供上层的视图层调用。 优点 无刷新体验，这个应该是最显著的有点，由于路由分发直接在浏览器端完成，页面是不刷新，对用户的响应非常及时，因此提升了用户体验； 完全的前端组件化，前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方式更加规范化，便于修改和调整； 组件共享，在某些对性能体验要求不高的场景，或者产品处于快速试错阶段，借助于一些技术（Hybrid、React Native），可以在多端共享组件，便于产品的快速迭代，节约资源。 缺点 首次加载大量资源 要在一个页面上为用户提供产品的所有功能，在这个页面加载的时候，首先要加载大量的静态资源，这个加载时间相对比较长； 较高的开发门槛 不利于SEO 单页页面，数据在前端渲染，就意味着没有 SEO，或者需要使用变通的方案。 单页面应用SEO http://www.ruanyifeng.com/blog/2013/07/how_to_make_search_engines_find_ajax_content.html https://ziyuan.baidu.com/college/articleinfo?id=294 使用一种可以编译成 JavaScript 的语言来写 JavaScript 代码有哪些优缺点？ 你使用哪些工具和技术来调试 JavaScript 代码？http://wiki.jikexueyuan.com/project/chrome-devtools/debugging-javascript.html https://segmentfault.com/a/1190000011857058 你会使用怎样的语言结构来遍历对象属性 (object properties) 和数组内容？http://es6.ruanyifeng.com/#docs/iterator 任何数据结构只要部署 Iterator 接口，就可以完成遍历操作 for...of for...in foreach 123Array.foreach(function(e)&#123; console.log(e);&#125;) 请解释可变 (mutable) 和不变 (immutable) 对象的区别。不变性 (immutability) 有哪些优缺点？如何用你自己的代码来实现不变性 (immutability)？http://www.cnblogs.com/Ziksang/p/5203551.html http://laichuanfeng.com/study/javascript-immutable-primitive-values-and-mutable-object-references/ JavaScript 中的原始值（undefained、null、布尔值、数字和字符串）与引用值（对象，数组，函数等）有着根本的区别。 存储方式 原始值 存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。 引用值 存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。 原始数据类型都是不可变的原始值，任何操作都不能改变他，只会返回一个新的值，或是给相应的变量赋给一个新的值。 123var s = "hello"; //定义一个由小写字母组成字符串s.toUpperCase(); //=&gt;“HELLO”，但并没有改变s的值s; //=&gt;“hello”：原始字符串的值并未改变。 原始值的比较是值的比较：只有在它们的值相等时它们才相等。这对数字、布尔值、null和underfined来说听起来有点难懂，并没有其他办法来比较他们。同样，对于字符串来说则并不明显：如果比较两个单独的字符串，当且仅当他们的长度相等且每个索引的字符都相等时，JavaScript 才认为它们相等。 123var arr = 'str';var arr2 = arr;console.log(arr === arr2); // true 引用值的比较并非值的比较：即使两个引用值包含同样的属性及相同的值，它们也是不相等的。各个索引元素完全相等的两个数组也不相等；我们通常将对象称为引用类型（reference type)，以此来和 JavaScript 的基本类型区分开来。依照术语的叫法，对象值都是引用（reference），对象的比较均是引用的比较：当且仅当它们引用同一个基对象时，它们才相等。并且，修改引用值时，基对象也会被修改（对象的浅拷贝）： 12345var a = []; //定义一个引用空数组的变量avar b = a; //变量b引用同一个数组b[0] = 1; //通过变量b来修改引用的数组a[0]; //=&gt; 1：变量a也会被修改a === b; //=&gt; true：a和b引用同一个数组，因此它们相同 阻塞I/O，非阻塞I/O同步IO和异步IO，它指的是应用程序和操作系统内核间的关系。 现代主流的两种资源分配方式： 单线程串行依次执行； 易造成I/O阻塞 多线程并行执行 多线程的代价在于创建线程和执行期线程上下文切换的开销较大。 阻塞I/O调用结果返回之前，当前线程会被挂起，特点是调用之后一定要等到系统内核层面完成所有操作之后，调用才结束。易造成CPU等待I/O，浪费等待时间，CPU处理能力得不到发挥。 非阻塞I/O指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。不带数据直接返回，但非阻塞i/o也存在一些问题：由于事件进程并未完成，需要重复调用I/O操作来确认是否完成。这种重复确认操作是否完成的技术叫做轮询。 请解释同步 (synchronous) 和异步 (asynchronous) 函数的区别。见博客 事件循环？调用栈和任务队列的区别调用栈是主线程上形成的执行栈，函数的执行就是同步的进栈与出栈的过程。 异步任务不直接进入主线程，而是进入任务队列，当‘任务对列’通知主线程某个异步任务可以执行时，该任务才会进入主线程执行。 http://www.ruanyifeng.com/blog/2014/10/event-loop.html]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css面经积累]]></title>
    <url>%2F2018%2F01%2F20%2Fcss%E9%9D%A2%E7%BB%8F%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[置换元素一个内容，不受CSS视觉格式化模型控制，CSS渲染模型并不考虑对此内容的渲染，一般都拥有固定尺寸（宽度、高度、高度比）的元素，称为置换元素。 例如浏览器会根据img的src属性值来读取图片信息并显示出来；又如根据input的type属性来决定是显示文本还是按钮等。 常见的替换元素有img input textarea select object。 行内元素、块状元素常见的块状元素有：div p form ul ol 常见的行内元素有：span strong em 区别 块状元素独占一行且宽度回沾满父元素的宽度，行内元素不会独占一行，且相邻元素可以同在一行。 块状元素可以设置宽高，且还是会独占一行；行内元素设置宽高无效。 块状元素可以设置margin padding属性；行内元素水平方向的margin padding属性，但是垂直方向不会产生边距效果。 块状元素对应的display:block,行内元素display:inline,display:inline-block属性可以让元素具有块状元素和行内元素特性：既可以设置宽高、设置边距、也可以与其他元素并排。 CSS 中类 (classes) 和 ID 的区别。 书写上的差别：class名用“.”号开头来定义，id名用“#”号开头来定义； 调用上的区别：在同一个html网页页面中class是可以被多次调用的（在不同的地方）。而id名作为标签的身份则是唯一的，id在页面中只能出现一次。在js脚本中经常会用到id来修改一个标签的属性 id是先找到结构/内容，再给它定义样式；class是先定义好一种样式，再套给多个结构/内容。 请问 “resetting” 和 “normalizing” CSS 之间的区别？你会如何选择，为什么？http://jerryzou.com/posts/aboutNormalizeCss/ Normalize.css 保护了有价值的默认值Reset通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。相比之下，Normalize.css保持了许多默认的浏览器样式。这就意味着你不用再为所有公共的排版元素重新设置样式。 请解释浮动 (Floats) 及其工作原理。先来说一下标准文档流这个概念，浏览器在解析过程中，会遵循从上到下、从左到右的顺序，这个顺序就是来源于标准文档流。所有的块状元素独占一行，自上到下；所有的行内元素从左到右，不换行。下图就是标准文档流，自上到下排列。 https://www.cnblogs.com/iyangyuan/archive/2013/03/27/2983813.html 如果想要让块状元素及行内元素改变原先的状态，除了display以外，还可以用float,position属性让元素脱离文档流。 浮动可以理解为让某个div脱离文档流，漂浮在标准流之上，和标准流不在一个层次上。 div2设置了浮动，div1,div3,div4仍在标准流中，所以div3自动向上移动，占据div2的位置，重新组成一个流。 上图div2，div3同时左浮动，div4上移，组成一个新的标准流，div2,div3浮动在标准流之上，因此div2遮挡住了div4. 清除浮动 clear:none | left | right | both 允许两边都可以浮动 | 不允许左浮动 | 不允许右浮动 | 不允许浮动 对于CSS的清除浮动(clear)，一定要牢记：这个规则只能影响使用清除的元素本身，不能影响其他元素。 描述z-index和叠加上下文是如何形成的。https://www.cnblogs.com/starof/p/4424926.html 先解释一个名词，“堆叠上下文”，每个元素仅属于一个堆叠上下文，元素的z-index在相同的堆叠上下文中按‘z轴’的顺序呈现。 默认情况 默认情况就是所有的元素都不使用z-index,堆叠顺序如下： 根元素的background和border 正常流中非定位的元素，会先于定位元素渲染，总是在定位元素的下方，如下图中的div5。 没有z-index的定位元素，他们的堆叠顺序取决于在html文档中的顺序，越靠后的元素，位置越高，与position属性无关。 上图渲染顺序为5&gt;1&gt;2&gt;3&gt;4 浮动元素堆叠 浮动元素堆叠位置位于非定位与定位元素之间 根元素的background和border 正常流中非定位的元素，会先于定位元素渲染，总是在定位元素的下方。 浮动元素 已定位的元素。 上图中，#4是正常流中元素，位于最底层；#2，#3是浮动元素，接着被渲染，彼此不会因为z-index而堆叠覆盖；#1，#5是定位元素，最后渲染，按出现顺序堆叠。渲染顺序为4&gt;2&gt;3&gt;1&gt;5。 z-index堆叠z-index只适合已经定位的元素，元素按z-indexD的值堆叠 在堆叠上下文中，子元素与父元素的堆叠上下文独立开来，互补影响。看下图。 为什么#4的z-index比#1高却在#1的下面呢？因为#4的z-index的值大，但他的作用域包含在#3内，而#1的z-index的作用域在html内，和#3同属html，而#3的z-index小于#1。同理#2在#5的下面。 `#3的z-index是4，但该值和#4,#5,#6的z-index不具有可比性，它们不在一个上下文环境。 如何轻易的判断两个元素的堆叠顺序？ Root-z-index值为默认auto，即0 DIV #2 - z-index 值为2 DIV #3 - z-index 值为4 DIV #5 - z-index值为 1,其父元素z-index值 4,所以最终值为4.1 DIV #6 - z-index值为 3,其父元素z-index值 4,所以最终值为4.3 DIV #4 - z-index值为 6,其父元素z-index值 4,所以最终值为4.6 DIV #1 - z-index 值为5 请描述 BFC(Block Formatting Context) 及其如何工作box是css布局的基本单位，一个页面就是由很多个box组成的。元素的类型和display属性决定了这个box的类型。不同类型的box,会参与到不同的Foomating Context（一个决定如何渲染文档的容器）中。 BFC：box-level box : display属性为blocak``list-item``table的元素，会生成box-level box,并参与BFC IFC： inline-level-box:display属性为inline``inline-block``inline-table的元素，会生成inline-level box,且参与到IEC。 Foomating Context 他是页面中的一块渲染区域，并且有一套渲染规则，他决定了其子元素将如何定位，以及和其他相邻元素的相互作用。 BFC块级格式化上下文 是一个独立的渲染区域，只有block-level box参与，规定了内部的block-level box如何布局，并且与区域外部不相干 布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 哪些元素会产生BFC 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible 123&lt;div style="border: 1px solid #000;"&gt; &lt;div style="width: 100px;height: 100px;background: #eee;float: left;"&gt;&lt;/div&gt;&lt;/div&gt; 由于float属性，脱离了文档流，容器只剩下2px的边距高度。如果触发容器的BFC，那么容器就会包裹浮动元素。常见的是使用overflow:hidden属性。 123&lt;div style="border: 1px solid #000;overflow: hidden"&gt; &lt;div style="width: 100px;height: 100px;background: #eee;float: left;"&gt;&lt;/div&gt;&lt;/div&gt; 清楚浮动https://www.jianshu.com/p/09bd5873bed4包裹性：给物体添加外层容器将其隔绝起来，且内部变动对外部不造成影响，形成BFC。破坏性：没有高度属性的容器使用float的子元素会造成父元素塌陷(!!!没有高度的父容器)， 在浮动元素后加一个clear:both：在被清除浮动的元素上边或者下边添加足够的清除空间 123456&lt;div class="box-wrapper"&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div style="clear:both;"&gt;&lt;/div&gt;&lt;/div&gt; 2.clear-fix 推荐！！！利用伪元素 1234567891011121314// 全浏览器通用的clearfix方案【推荐】// 引入了zoom以支持IE6/7// 同时加入:before以解决现代浏览器上边距折叠的问题.clearfix:before,.clearfix:after &#123; display: table; content: " ";&#125;.clearfix:after &#123; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125; 3.BFC 123.box-wrapper&#123; overflow: hidden;&#125; 请解释 CSS sprites，以及你要如何在页面或网站中实现它CSS sprite即把网页中比较小的一些小图片整合到一张图片文件中，再利用CSS的background-image属性插入图片，然后利用background-position属性对图片所需要的部分进行精确定位，从而达到减少服务器请求次数的目的。 图片替换方法http://nicolasgallagher.com/css-image-replacement-with-pseudo-elements/ http://blog.csdn.net/cwzhsi/article/details/46403077 你会如何解决特定浏览器的样式问题 如何为有功能限制的浏览器提供网页？渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 相关技术:Media QueryCSS hack条件判断&lt;! –[if !IE]&gt;除IE外都可识别 有哪些的隐藏内容的方法 (如果同时还要保证屏幕阅读器可用呢)？ display:none搜索引擎可能认为被隐藏的是垃圾信息而被忽略，屏幕阅读器（是为视觉上有障碍的人设计的读取屏幕内容的程序）会忽略被隐藏的文字 visibility:hidden：隐藏的内容会占据物理空间。即内容虽被隐藏，但是文档流的位置会出现空白 overflow:hidden 123456.div&#123; display:block //转化成块状元素 overflow:hidden height:0 width:0 //宽高设为0，超出的部分隐藏&#125; 你用过栅格系统 (grid system) 吗？如果使用过，你最喜欢哪种？bootstrp栅格系统响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。 http://v3.bootcss.com/css/#grid-example-fluid 123456789101112131415&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-8&quot;&gt;.col-md-8&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt; &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 你用过媒体查询，或针对移动端的布局/CSS 吗？https://www.ibm.com/developerworks/cn/web/wa-cssqueries/index.html 响应式设计的一种方法 你熟悉 SVG 样式的书写吗？ 如何优化网页的打印样式？http://blog.csdn.net/xujie_0311/article/details/42271273https://www.cnblogs.com/huashanqingzhu/p/4345698.html 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;xxx.css&quot; /&gt; 其中media指定的属性就是设备，显示器上就是screen，打印机则是print，电视是tv，投影仪是projection。 但打印样式表也应有些注意事项： 1、打印样式表中最好不要用背景图片，因为打印机不能打印CSS中的背景。如要显示图片，请使用html插入到页面中。 2、最好不要使用像素作为单位，因为打印样式表要打印出来的会是实物，所以建议使用pt和cm。 3、隐藏掉不必要的内容。（@print div{display:none;}） 4、打印样式表中最好少用浮动属性，因为它们会消失。 在书写高效 CSS 时会有哪些问题需要考虑?1）reset。参照下题“描述下 “reset” CSS 文件的作用和使用它的好处”的答案。 2）规范命名。尤其对于没有语义化的html标签，例如div，所赋予的class值要特别注意。 3）抽取可重用的部件，注意层叠样式表的“优先级”。 css预处理器主流的有less,sass,stylus http://lesscss.org/features/#features-overview-feature 优点：CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。 缺点：学习成本高，可维护性差；加上模块化组件的兴起，组件化思想流行，可维护性强 非标准字体http://blog.csdn.net/xujie_0311/article/details/42368371 1、用图片代替 2、web fonts在线字库，如Google Webfonts，Typekit等等；http://www.chinaz.com/free/2012/0815/269267.shtml； 3、@font-face，Webfonts 请解释浏览器是如何判断元素是否匹配某个 CSS 选择器？http://blog.csdn.net/qq_21397815/article/details/72874932 从右向左判断 请描述伪元素 (pseudo-elements) 及其用途。css3中用::两个冒号来表示伪元素::before,::after，以区分伪元素和伪类:hover,:active. 伪元素不属于html文档，所以js无法操作他； 伪元素作为主元素的一部分，因此点击事件的触发实际上是在主元素上触发 请解释你对盒模型的理解，以及如何在 CSS 中告诉浏览器使用不同的盒模型来渲染你的布局。W3C盒子模型——属性高（height）和属性宽（width）这两个值不包含 填充（padding）和边框（border） IE盒子模型——属性高（height）和属性宽（width）这两个值包含 填充（padding）和边框（border） http://blog.csdn.net/xujie_0311/article/details/42372871 * { box-sizing: border-box; }的作用与好处IE对盒模型的解析出现一些问题，跟其它浏览器不同，将 border 与 padding 都包含在 width 之内。而另外一些浏览器则与它相反，是不包括border和padding的。对于IE浏览器，当我们设置 box-sizing: content-box; 时，浏览器对盒模型的解释遵从我们之前认识到的 W3C 标准，当它定义width和height时，它的宽度不包括border和padding；对于非IE浏览器，当我们设置box-sizing: border-box; 时，浏览器对盒模型的解释与 IE6之前的版本相同，当它定义width和height时，border和padding则是被包含在宽高之内的。内容的宽和高可以通过定义的“width”和 “height”减去相应方向的“padding”和“border”的宽度得到。内容的宽和高必须保证不能为负，必要时将自动增大该元素border box的尺寸以使其内容的宽或高最小为0。 使用 * { box-sizing: border-box; }能够统一IE和非IE浏览器之间的差异。 https://www.jianshu.com/p/2353c364318b block,inline-block,inline的区别https://www.cnblogs.com/Ry-yuan/p/6848197.html inline:使元素变成行内元素，拥有行内元素的特性，即可以与其他行内元素共享一行，不会独占一行. 不能更改元素的height，width的值，大小由内容撑开. 可以使用padding，margin的left和right产生边距效果，但是top和bottom就不行. block:使元素变成块级元素，独占一行，在不设置自己的宽度的情况下，块级元素会默认填满父级元素的宽度. 能够改变元素的height，width的值. 可以设置padding，margin的各个属性值，top，left，bottom，right都能够产生边距效果. inline-block:结合了inline与block的一些特点，结合了上述inline的第1个特点和block的第2,3个特点. 用通俗的话讲，就是不独占一行的块级元素。 请解释 relative、fixed、absolute 和 static 元素的区别http://blog.163.com/love_heartbreaking/blog/static/124561901201211334714800/ 1、static：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 2、relative：生成相对定位的元素，通过top,bottom,left,right的设置相对于其正常位置进行定位。可通过z-index进行层次分级。 3、absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。 4、fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。 relative,absolute的区别 1、relative。定位为relative的元素脱离正常的文本流中，但其在文本流中的位置依然存在。absolute。定位为absolute的层脱离正常文本流，但与relative的区别是其在正常流中的位置不在存在。 2、relative定位的层总是相对于其最近的父元素，无论其父元素是何种定位方式。 abosulte红色背景层依然定义top:20px；left:20px；但其相对的元素变为定位方式为absolute或relative的黄色背景层。因此，对于absolute定位的层总是相对于其最近的定义为absolute或relative的父层，而这个父层并不一定是其直接父层。如果其父层中都未定义absolute或relative，则其将相对body进行定位 css样式的优先级https://www.cnblogs.com/qjqcs/p/5024016.html?utm_source=tuicool&amp;utm_medium=referral CSS三种位置写法的优先级是：行内样式＞内页样式＞外部样式 从样式选择器看权重优先级：important &gt; 内嵌样式 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 继承 &gt; 通配符。 important的权重为1,0,0,0 ID的权重为0,1,0,0 类的权重为0,0,1,0 标签的权重为0,0,0,1 伪类的权重为0,0,1,0 属性的权重为0,0,1,0 伪对象的权重为0,0,0,1 通配符的权重为0,0,0,0 css框架boostrap 不兼容ie6； jquery mobile:http://blog.jobbole.com/30216/ （不能访问摄像头，相册） 请问你有尝试过 CSS Flexbox 或者 Grid 标准规格吗？flexbox 阮一峰 响应式设计 自适应设计http://www.woshipm.com/pd/153425.html 响应式设计主要运用媒体查询和viewport来解决问题缺点：需要考虑多种情况，制定多种专门的样式 自适应设计 兼容 retina 屏幕http://www.ui.cn/detail/24556.html 当一个图像在标准设备下全屏显示时，一位图像素对应的就是一设备像素，导致一个完全保真的显示，因为一个位置像素不能进一步分裂。而当在Retina屏幕下时，他要放大四倍来保持相同的物理像素的大小，这样就会丢失很多细节，造成失真的情形。 在普通屏幕下，1个css像素 对应 1个物理像素(1:1)。在retina 屏幕下，1个css像素对应 4个物理像素(1:4)。 直接加载两倍大的图片，但是在一般屏幕下图片经过压缩，加载时间长。可以使用retina.js 准备两张尺寸的照片 媒体查询 translate 与 position二者都可以实现元素的位移，且效果一样；差别在于，transform 可以简单地作用于 position:absolute 的元素上面，而 position:relative; 还得加额外的 html 从动画角度来说 使用 transform 或 position 实现动画效果时是有很大差别。 使用 transform 时，可以让 GPU 参与运算，动画的 FPS 更高。 使用 position 时，最小的动画变化的单位是 1px，而使用 transform 参与时，可以做到更小（动画效果更加平滑） 总结 position 是为页面布局而生的。 transform 是为动画而生的。 https://segmentfault.com/a/1190000002436755 水平居中 行内元素 父元素：text-align:center 块状元素 必须设置width, 然后设置margin:0 auto; 不确定高度的块状元素 父元素：text-align:center 子元素:display:inline/inline-block 设置子元素：display:table; margin:0 auto; transform:tanslate(-50%,-50%); display:flex; justify-content:center 垂直居中 display:flex;algin-item:center; translate(-50%,-50%) 设置父元素：position:relative; 设置子元素：position:absolute; margin-top:(父元素height-子元素height)/2; 幻灯效果页面主要运用了animation动画效果；不听改变图片的透明度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.cb-slideshow&#123; width:400px; height:400px; margin:0 auto; z-index:0; &#125; .cb-slideshow li&#123; position:absolute; width:400px; height:400px; background-size:cover; background-repeat: none; opacity:0; z-index:0; -webkit-animation: loops 36s linear infinite 0s; &#125; .cb-slideshow li:nth-child(1)&#123; background-image: url(images/m10.jpg); &#125; .cb-slideshow li:nth-child(2)&#123; background-image: url(images/m11.jpg); -webkit-animation-delay: 6s; &#125; .cb-slideshow li:nth-child(3)&#123; background-image: url(images/m12.jpg); -webkit-animation-delay: 12s; &#125; .cb-slideshow li:nth-child(4)&#123; background-image: url(images/m15.jpg); -webkit-animation-delay: 18s; &#125; .cb-slideshow li:nth-child(5)&#123; background-image: url(images/m16.jpg); -webkit-animation-delay: 24s; &#125; .cb-slideshow li:nth-child(6)&#123; background-image: url(images/m17.jpg); -webkit-animation-delay: 30s; &#125; @-webkit-keyframes "loops" &#123; 0% &#123; opacity: 0; &#125; 8% &#123; opacity:1; &#125; 17% &#123; opacity:1; &#125; 25% &#123; opacity:0.5; &#125; 100% &#123; opacity: 0; &#125; &#125; 12345678&lt;ul class="cb-slideshow"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 什么是无样式内容闪烁?如何避免?先说说网页的渲染机制： 浏览器会解析这么三个东西：一个是html/svg/xhtml,解析他们会产生dom树；二是css文件，构建css rule tree(产生CSSOM：css object model);三是js脚本，通过dom api和cssom api来操作dom树和cssom 解析完成后，通过DOM tree和css rule tree构建渲染树rendering treeRendering Tree并不等同于DOM Tree，因为像header和display:none相关的东西就没有必要放在Rendering 渲染树中了CSS Rule Tree主要是为了将CSS Rule添加到Rendering Tree中的每一个element中，也就是DOM节点，然后计算每个DOM节点的位置，这个过程叫做layout，最后将页面绘制出来。 白屏和无样式内容闪烁（FOUC） https://zhuanlan.zhihu.com/p/29418126 白屏和FOUC（无样式内容闪烁）的产生主要与浏览器的渲染机制有关，有的浏览器是等待html和css全部加载完成后再进行渲染（白屏问题），有的浏览器是先显示已加载的html内容，等到css加载完成后重新对内容添加样式（FOUC问题） 白屏的产生白屏的产生有三种情况：将css文件放在html文档的最后、使用@import引入css（因为通过@import引入的css文件会被最后加载，因此也会导致白屏）或者将js文件放在头部，而未使用defer或async延迟或异步加载js文件，导致js阻塞html和css的加载 FOUC的产生主要是由于浏览器先显示已加载的html内容，等到css加载完成后重新对内容添加样式导致的，主要代表有Firefox 如何避免 将css文件引用写在head标签里，不要@import css文件 将js文件引用写在前。 加载异步：defer和asnyc是脚本异步加载的两种方式。 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但 script.js 的执行要在所有元素解析完成之后DOMContentLoaded 事件触发之前完成。async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 css阻塞相关 https://www.jianshu.com/p/db82a546267a]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class与继承]]></title>
    <url>%2F2017%2F12%2F23%2FClass%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[简介ES5的继承，实质上是先创造子类的实例对象this,然后再将父类的方法添加到this上面。 123456function superType()&#123; this.colors = ['red','blue','black']&#125;function subType()&#123; superType.call(this);&#125; ES6的继承机制是：实例先创造父类的实例对象this(所以调用super方法),然后再用子类的构造函数修改this 1234567class colorPoint extends Point&#123; constructor(x,y,color)&#123; super(x,y)//调用父类构造函数中的（x,y） //super表示父类的构造函数，用来新建父类的this对象 this.color = color; &#125;&#125; 有两点需要注意的地方： 如果子类没有定义constructor方法，这个方法会被默认添加，即任何一个子类都有constructor方法; 子类构造函数中，只有调用super之后，才能使用this关键字，否则会报错；ES6要求，子类必须调用一次super函数 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 &#125;&#125; supersuper既可以当对象使用，也可以当函数使用 super用作函数是调用，代表父类的构造函数。 ES6要求，子类的构造函数中必须执行一次super函数。 1234567891011class A&#123;&#125;class B extends A&#123; constructor()&#123; super(); //super虽然指向的是父类的构造函数，但是返回的是子类B的实例 //即super内部的this指向是B //A.prototype.constructor.call(this) &#125;&#125;new A() //Anew B() //B super作为对象时，指向父类的原型对象 1234567891011calss A&#123; p()&#123; return 2 &#125;&#125;class Bextends A&#123; constructor()&#123; super(); console.log(super.p()) //2 //指向`A.prototype` 即`A.prototype.p()` &#125;&#125;let b = new B(); 类的prototype属性和 proto属性大多数浏览器的 ES5 实现之中，每一个对象都有 __ proto__属性，指向对应的构造函数的prototype属性,而在ES6中： 子类的_ proto _属性，表示构造函数的继承，总是指向父类. 123class AA&#123;&#125;class BB extends AA&#123;&#125;BB.__proto__ //class AA&#123;&#125; 子类prototype属性的_proto_属性，表示方法的继承，总是指向父类的prototype属性 12BB.prototype //AA &#123;constructor: ƒ&#125;BB.prototype.__proto__ //&#123;constructor: ƒ&#125; 实例的 proto属性子类实例的__ proto__属性的__ proto__属性，指向父类实例的__ proto__属性。也就是说，子类的原型的原型，是父类的原型。 1234var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, 'red');p2.__proto__.__proto__ === p1.__proto__ // true 因此通过子类实例的_ proto_._ proto_属性，可以修改父类实例的行为。 12345p2.__proto__.__proto__.printName = function () &#123; console.log('Ha');&#125;;p1.printName() // "Ha" 原生构造函数的继承extends关键字不仅可以用来继承类，还可以用来继承原生构造函数。ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象的this，然后再用子类构造函数修饰this，使得父类所有的行为都可以被继承。123456789101112class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;var arr = new MyArray();arr[0] = 12;arr.length // 1arr.length = 0;arr[0] // undefined]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之Generator和async函数]]></title>
    <url>%2F2017%2F12%2F21%2FGenerator%E5%92%8Casync%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Generator函数有多种理解：首先它可以理解成是一个状态机，封装了许多的内部状态； 其次，它也是一个遍历器对象的生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。 Generator函数是一个普通函数，但有两个特质： （1）function关键字与函数名之间有一个*号 （2）函数体内使用yield表达式，定义不同的内部状态 Generator简介12345678910111213function* Hello() &#123; yield 100 yield (function () &#123;return 200&#125;)() return 300&#125;var h = Hello()console.log(typeof h) // objectconsole.log(h.next()) // &#123; value: 100, done: false &#125;console.log(h.next()) // &#123; value: 200, done: false &#125;console.log(h.next()) // &#123; value: 300, done: true &#125;console.log(h.next()) // &#123; value: undefined, done: true &#125; 执行var h = hello()生成一个Generator对象，不是普通的函数 执行hello()之后，hello内部的代码不会立即执行，而是处于一个暂停的状态 执行第一个h.next()时，会激活刚才的暂停状态，开始执行Hello内部的语句，但是，直到遇到yield语句。一旦遇到yield语句时，它就会将yield后面的表达式执行，并返回执行的结果，然后又立即进入暂停状态 执行第三个h.next()时，程序会打破暂停状态，继续往下执行，但是遇到的不是yield而是return。这就预示着，即将执行结束了。因此最后返回的是{ value: 300, done: true }，done: true表示执行结束，无法再继续往下执行了 Genarator基本操作遍历器对象Generator生成了一个遍历器对象，即Interator接口 1234567function* Hello() &#123; yield 100 yield (function () &#123;return 200&#125;)() return 300 &#125;const h = Hello()console.log(h[Symbol.iterator]) // [Function: [Symbol.iterator]] 执行hello()可以得到一个遍历器对象，可以使用next()或for...of进行操作 123456789console.log(h.next()) // &#123; value: 100, done: false &#125;console.log(h.next()) // &#123; value: 200, done: false &#125;console.log(h.next()) // &#123; value: 300, done: false &#125;console.log(h.next()) // &#123; value: undefined, done: true &#125;let ifor (i of h) &#123; console.log(i)&#125; 异步操作协程“协程”（coroutine），意思是多个线程互相协作，完成异步任务。一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。 协程A开始执行 协程A执行到一半，进入暂停，执行权转移到协程B 协程B交换执行权 协程A回复执行 123function* asyncJob()&#123; var f = yield readFile(fileA);&#125; asyncJob就是一个协程，yield命令表示执行到此处，执行权交给其他协程。协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。 thunk函数123456789101112// 正常版本的readFile（多参数版本）fs.readFile(fileName, callback);//Thunk版本var Thunk = function(filename)&#123; return function(callback)&#123; return fs.readFile(filename,callback) &#125;&#125;;var readFileThunk = Thunk(filename);readFileThunk(callback); 上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。 Gnerator中使用Thunk函数1234567const readFileThunk = thunkify(fs.readFile)const gen = function* () &#123; const r1 = yield readFileThunk('data1.json') console.log(r1) const r2 = yield readFileThunk('data2.json') console.log(r2)&#125; 需要注意的是这里调用函数的next()方法返回的是以回调函数为参数的Thunck函数，但这些仍然是一个手动执行流程。 Generator本质Generator能让一段程序执行到指定的位置先暂停，然后再启动，再暂停，再启动。 而这个 暂停 就很容易让它和异步操作产生联系，因为我们在处理异步操作时，即需要一种“开始读取文件，然后暂停一下，等着文件读取完了，再干嘛干嘛…”这样的需求。因此将Generator和异步操作联系在一起，并且产生一些比较简明的解决方案，这是顺其自然的事儿，大家要想明白这个道理。 不过，JS 还是 JS，单线程还是单线程，异步还是异步，callback还是callback。这一切都不会因为有一个Generator而有任何变化。 async-awaitawait后面跟的不再是一个thunk函数，而是一个promise对象。 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123; console.log(result);&#125;); async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之Promise]]></title>
    <url>%2F2017%2F12%2F08%2Fpromise%20ES6%2F</url>
    <content type="text"><![CDATA[Promise介绍promise是异步编程的一种解决方案，而传统的方案指的是回调函数或事件。 promise的本质上还是回调函数，通过注册promise对象执行成功与失败时的相应的回调函数。 但与回调函数方式有什么不同呢？在使用promise进行进一步处理时，唏嘘按照接口规定的方式编写处理代码。除promise对象规定的方法以外的方法是不可以使用的。而传统的异步请求是可以自己自由的定义回调函数的参数。 一方面增加了代码的可读性与理解性；一方面也是可以将复杂的异步处理进行模块化。 promise就像一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果，通过状态的改变来执行下一步的操作。 promise三种状态 pending–进行中（异步操作的初始状态） fulfilled–已成功 rejected–已失败 只有异步操作的结果才能决定当前是哪一种状态，任何其他操作都无法改变这个状态。 promise对象是一个构造函数，用来生成promise实例。promise构造函数接受一个函数作为参数，该函数有resolve和reject两个参数。resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 12345678const promise = new Promise(function(resolve,reject)&#123; ...some code&#125;);promise.then(function(value)&#123; //success&#125;,function(error)&#123; //fail&#125;) 基本用法12345678910function asynFunction()&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function () &#123; resolve('Async Hello world'); &#125;, 16); &#125;);&#125;asyncFunction().then((value) =&gt; console.log(value)) // =&gt; 'Async Hello world'.catch((error) =&gt; console.log(error)); 上述代码中，asynFunction()返回一个promise对象，且为该对象设置了.then调用时的回调函数。该promise对象会在setTimeout之后的16ms时被resolve, 这时 then 的回调函数会被调用，并输出 Async Hello world 。 缺点 不适用于多次触发的事件 不能取消执行 无法获取当前执行的进度信息 一些point1. Promise在新建后就会立即执行。123456789101112let promise = new Promise(function(resolve,reject)&#123; console.log('promise'); resolve();&#125;) promise.then(function()&#123; console.log('resolved'); &#125;) console.log('hi'); //promise //hi //resolved 由于promise在新建后会立即执行，所以首先输出的是promise，然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 2.Promise.prototype.catch()Promise.prototype.catch()用来处理promise实例发生错误时的回调函数，是.then(null,rejection)的别名。 12p.then((val) =&gt; console.log('success')).catch((err) =&gt; console.log('failed'));]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 6种声明变量的方法]]></title>
    <url>%2F2017%2F09%2F08%2FES6%206%E7%A7%8D%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[除了var，function以外，ES6新增了6种声明变量的方法。 let命令let声明的变量，只能在其命令所在的代码块内有效。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的几种布局]]></title>
    <url>%2F2017%2F09%2F08%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[两列布局左列定宽，右列自适应12.left&#123;float：left; width:100px;&#125;.right&#123;margin-left:100px&#125; IE6会有3像素的bug 三列布局这三种布局基本都是当今网页布局比较常用的布局方式：左中右三栏布局，左右两栏宽度固定（要是不想固定将宽度改成百分比），中间栏宽度自适应。 绝度定位法左右两栏采用绝对定位，固定于页面两侧；中间栏用左右margin值撑开距离。 12345&lt;body&gt; &lt;div id="left" style="position:absolute; width:200px; left:0;"&gt;&lt;/div&gt; &lt;div id="main" style="margin:0 210px"&gt;&lt;/div&gt; &lt;div id="right" style="position:absolute; width:200px;"&gt;&lt;/div&gt;&lt;/body&gt; margin负值法这种方法是在实际的网站中应用的最多的，中间主体使用双层标签，内层div为真正的主体内容，含有左右210像素的margin值。左右栏采用maigin负值定位：margin-left:-100% 1234567&lt;body&gt; &lt;div style="float:left margin:0;"&gt; &lt;div width:100%,float:left&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id="left" style="width:200px; margin-left:-100%;float:left"&gt;&lt;/div&gt; &lt;div id="right" style=" width:200px; margin-left:-200px;float:left"&gt;&lt;/div&gt;&lt;/body&gt; 自身浮动法左栏左浮动，右栏右浮动，中间部分自适应12345&lt;body&gt; &lt;div id="left" style="width:200px; float:left"&gt;&lt;/div&gt; &lt;div id="right" style="width:200px; float:right"&gt;&lt;/div&gt; &lt;div style="margin:0 210px;"&gt;&lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP首部字段]]></title>
    <url>%2F2017%2F09%2F08%2Fhttp%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[http协议的请求和响应报文必定包含http首部首部内容是客户端和服务器请求或响应时所提供的需要的信息。 请求报文与响应报文构成请求报文由方法，URI，http版本、首部字段组成。 响应报文由http版本，状态码，首部字段组成。 构成 请求报文 响应报文 报文首部 请求行、通用/请求/实体首部字段 请求行、通用/请求/实体首部字段 主体部分 报文主体 报文主体 首部字段首部字段在客户端与服务器通信中，起到传递重要信息的作用。首部字段是为了给浏览器 和服务器提供报文大小、认证信息、缓存等内容。 字段结构 首部字段名：字段值 4种字段类型 通用首部字段 请求/相应首部字段 实体首部 接下来我们详细讲一下每个字段的具体内容 http/1.1通用首部字段通用首部字段指的是请求报文和响应报文都会使用的首部。 1. Cache-Control通过指定Cache-Control的值，就能操作缓存的工作机制。指令可为多个，且用”，“来间隔 1Cache-Control: private, max-age = 0, no-cache 表示能否缓存的指令 public指令 表明可向任一用户提供响应的缓存 private指令 与public相对的，表明响应的缓存只向特定用户提供 no-cache指令 确定缓存的有效性，防止返回过期的缓存 客户端请求包含no-cache：表示客户端不会接受缓存服务器发来的缓存，处于中间的缓存服务器就会把请求发给源服务器。 服务器请求包含no-cache：缓存服务器不能对资源进行缓存。以后也不会对缓存服务器的资源进行确认，且禁止对任何资源进行缓存。 1Cache-Control:no-cache = Location 如果对字段名指定具体参数值，客户端接受到服务器返回的响应报文后，就不能使用缓存了。也就是说，无村塾的首部字段可以使用缓存。++且该参数只能在响应报文中指定。++ 控制可执行缓存的对象的指令 no-store指令 规定不能缓存请求或响应的任一部分 指定缓存期限和认证的指令 s-maxage 只适用于拱多位用户使用的公共缓存服务器 1Cache-Control:s-maxage = 604800（秒） max-age 客户端角度 如果在缓存期限内，即判定当前的缓存期限小于指定时间，则向客户端发送缓存的数据。1Cache-Control:s-maxage = 0（秒） 当值为0时，那么缓存服务器需要将请求发送给园服务器。 服务器角度 缓存服务器不再对缓存的期限进行确认。 min-fresh指令 超过期限就无法返回缓存，只返回指定时间内的缓存。 max-scale缓存过期也照常接收。 only-if-cached 客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。缓存服务器不重新加载响应，不确认缓存的有效性。 must-revalidate指令 代理服务器向源服务器确定缓存的有效性。 proxy-cache 所有缓存服务器在接受客户端带有该指令的情求返回响应之前，必须再次验证缓存的有效性。 no-transform 缓存不能改变实体主体的媒体类型。 2. Connection指令具有两个作用： 控制不再转发给代理的首部字段：可控制代理服务器不再转发部分字段 1Connection: 不再转发的首部字段名 管理持久连接 1Connection:close http/1.1默认状态下是持久连接的。 1Connection：Keep-Alive http/1.1之前的版本都是非持久连接的，所以可以指定字段值keep-alive. 3. Date表明创建报文的日期和时间 4. Pragma1Pragma:no-cache 所有的中间服务器的http版本不一定都是1.1，因此发送的请求会包含下面两个字段 12Cache-Control:no-cachePragma:no-cache 5. Trailer该字段会实现说明在斑纹主体后记录了哪些首部字段 123Trailer:Expries...报文主体...Expries:详细内容 6.Transfer-Encoding7. Upgrade用于检测http协议以及其他协议是否可使用更高的版本进行通信 12upgrade: TLS/1.0Connection: ugrade upgrade首部字段产生作用的对象仅限于客户端与邻接服务器，因此在指定upgrade字段时还得指定connection字段。 8.via追踪客户端和服务器之间请求或响应报文的传输路径。 9.Warning1Warning:[警告码][警告主机：端口号][警告内容][日期] http/1.1请求首部字段1.hosthost会告知服务器，请求的资源所处的互联网主机名和端口号 一个IP地址可对应多个域名：一台服务器（虚拟主机）只有一个IP，上面可以存放千万个网站，当这些网站请求到来时，服务器会根据host字段的值中的主机名来确定本次请求的资源在哪个服务器上。 IP地址相当于通信地址，都是由数字组成的，不利于记忆，因此为了方便记忆，定义了域名，所以人们都是访问baidu.com，而不是ip地址。 1host:www.baidu.com http/1.1响应首部字段1.varyvary可对缓存进行控制，源服务器向代理服务器传达关于缓存使用方法的命令。 当客户当与代理服务器都带有相同值的vary指令时，那么就直接从代理服务器发送缓存给客户端，如果不相同，则向源服务器发送请求。 从代理服务器收到源服务器返回的包含vary的响应后，如果再要进行缓存，则仅对请求中的vary指令值相同时返回缓存。]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型]]></title>
    <url>%2F2017%2F09%2F08%2F%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[探讨原型之前，我们先探讨下对象和函数的关系： 对象与函数我们一直都知道，函数是对象的一种，通过instanceof函数可以判断；再去看数据，我们也知道数组也是对象的一种，他就是数组的一个子集；但是我们又可以说所有对象都是通过函数创建的；所以，函数和对象的关系有种鸡生蛋蛋生鸡的关系 123var obj = new object();obj.a = 10;obj.b = 5; 原型与原型链原型prototype我们得先弄清原型、实例、构造函数三者之间的关系 首先 每个函数都具有prototype这个属性，函数的prototype属性指向函数的原型 其次，每个原型对象都具有一个constructor指针指向构造函数本身； 再者，每个对象都具有一个隐式原型 proto指向他的原型，所以，所有实例也指向原型对象 每个对象都有一个proto属性，指向创建该对象的函数的prototype 12person.prototype.constructor = person;new person()._proto_ = person.prototype; 由于所有函数也是对象，所以函数也会有自己的原型，他的prototype属性会指向她的原型，而所有的函数也具有自己的函数原型，所有的函数原型也是对象，都是被object创建，所以他的proto属性指向object.prototype.但是Object.prototype确实一个特例——它的proto指向的是null ###原型链的两个问题 1.众所周知的是，原型对象的所有属性会被所有是咧共享，所以一部分实例属性应该定义在构造函数中，而共享的原型属性应写在原型对象中。原型对象也具有这样的问题，原型会成为另一个对象的实例，所以实例属性就变成了原型属性。 2.在创建子类型的实例时，不能向超类型的构造函数中传递参数 问题解决：组合继承 原型链和借用构造函数的组合，使用原型链实现对原型属性的继承，使用构造函数实现对实例属性的继承，call()方法实现继承，并传入参数。看下面这个例子： 12345678910111213141516171819202122232425262728function sup(name)&#123; this.name = name; this.color = ["red","blue"] //构造函数里定义了name,color属性 &#125;; sup.prototype.sayname = function()&#123; alert(this.name); &#125;; function sub(name,age)&#123; sup.call(this,name);//继承了sup的构造函数属性 第二次调用 this.age = age; &#125;; sub.prototype = new sup();//sub原型指向sup的实例，具有了name,color属性 第一次调用sup sub.prototype.constructor = sub; sub.prototype.sayage = function()&#123; alert(this.age); &#125;; var instance1 = new sub("Nick",29); instance1.color.push("black") alert(instance1.color);//"red","blue","black" instance1.sayname();//"Nick" instance1.sayage();//29 var instance2 = new sub("John",31); alert(instance1.color);//"red","blue" instance1.sayname();//"John" instance1.sayage();//31 由于sub的原型指向了sup的实例，所以存在sup构造函数里的name,color属性也继承到了sub的原型里，因此，运行函数是，可以在sub的原型对象里找到name,color属性。 但由于运用了call()函数，所以sub的构造函数的对象里也具有color,name的实例属性，所以，当构造函数sub()调用时，首先搜索的是构造函数里的实例属性。所以，每个实例，instance1,instance2都有自己的实例属性的副本。 组合式继承融合了原型链和构造函数的优点，成为js中最常用的继承模式。 上述例子由于两次调用sup函数而使得在instance实例和sub原型中具有两个相同的同名属性，为了解决这个问题便引出了寄生组合式继承，详见书173页。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2017%2F09%2F08%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[对于闭包的理解就是用来读取函数内部变量的函数。在js中只有子函数才能读取去不函数内的变量，因此，闭包就是定义在一个函数内部的函数。 123456789 function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js单线程相关理解]]></title>
    <url>%2F2017%2F09%2F08%2Fjs%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一直不太理解单线程是什么意思，刚看了一些博客的讲解好像懂了一些。今天就来谈谈这个问题。 js是单线程的，这是毋庸置疑的，那么js是怎么实现异步请求的呢？js本身是不可能异步的，但js的宿主环境，如浏览器、node都是多线程的，宿主环境通过某种方式使得js具备了异步的属性。 js为什么是单线程的？js的单线程机制，与它用途有关。作为浏览器脚本语言，js的主要用途是与用户互动，以及操作DOM。这就决定了它的单线程。 如果js同时有两个线程，一个线程在某个节点上添加了内容，另一个线程删除了这个节点，这就导致了混乱，所以js从一诞生就是单线程的。 浏览器的多线程浏览器是多线程的，浏览器只给js分配了一个线程来执行任务（函数），但由于js是单线程的，因此一次只能执行一个任务，这些任务形成一个任务队列（callback queue）等候执行。这意味着完成队列的所有任务会非常的耗时，且效率低。所以浏览器为这些耗时的任务开辟了另外的线程，并由这些线程实现异步。 下面是浏览器的主要线程： 界面渲染线程 浏览器事件触发线程 http请求线程 js引擎线程 任务队列callback queue单线程意味着所有任务都得排队，前一个没有结束，后一个任务就得一直等着。只有前一个任务执行完了才会执行下一个任务。但是在开发的后期，人们逐渐意识到不必等前一个任务结束再折行下一个任务（如IO设备，ajax操作）。可以把处于等待中的任务挂起，先运行排在后面的任务。等IO设备返回了结果再回头把挂起的任务继续执行下去。 于是所有的任务分为两种，同步任务和异步任务。同步指的是在主线程上排队执行的任务，只有前一个任务执行完毕，才会执行后一个任务； 异步任务指的是，不进入主线程，而是进而任务队列的任务，只有任务队列“通知”主线程异步任务可以执行了，就会执行任务队列的任务。 异步执行的运行机制如下:(同步执行也是如此，可视为没有异步任务的异步执行) 所有的同步任务都在主线程上执行，形成一个执行栈 主线程外，还存在一个“任务队列”，只有异步运行有了结果，就会在“任务队列”中放置一个事件。（这里的事件在我的理解是通过回调函数进入任务队列） 执行栈中的所有同步任务执行完毕，系统会处理“任务队列”里的任务。并进入执行栈，开始执行 主线程不断重复上面的第3步。 上图很好的诠释了异步的机制，也展现出异步的优点。 回调函数在讲任务队列之前我得先讲一下回调函数，因为看到这里时对回调函数产生了模糊。特地仔细研究了下回调函数。之前对于回调函数接触是在ajax里面，ajax请求返回后才执行回调函数里面的内容。 “任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 而这些事件是怎么进入“任务队列”的呢？答案是回调函数。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 事件循环 Event Loop主线程从“任务队列”中读取事件，这个循环的过程又被称为事件循环Event loop。 主线程在运行的时候，产生堆（heap）和栈（stack），函数的执行就是通过进栈和出栈实现的，栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。 定时器“任务队列”还可以放置定时事件。setTimeout()函数接收两个参数，一个是回调函数，一个是任务执行前需等待的时间。 12345console.log(1);setTimeout(function()&#123; consoloe.log(2);&#125;,1000);console.log(3); //1,3,2 setTimeout()将第二行推迟到1000毫秒之后执行。 12setTimeout(function()&#123;console.log(1);&#125;,0);console.log(2); //2,1 如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。 总之，setTimeout(fn,0)指的是某个任务在主线程最早可得的空闲时间执行，也就是尽可能早的执行。他在任务队列的尾部添加了一个时间，因此要等到所有同步任务和“任务队列”的任务处理完，再会执行。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
